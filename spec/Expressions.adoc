== Expressions

=== Integer Literals

An *integer literal expression* is one of the following:

* A sequence of decimal digits `0` through `9` denoting the decimal
representation of a nonnegative integer.

* `0x` or `0X` followed by a sequence of hexadecimal digits
`0` through `9`, `A` through `F`, or `a` through `f` denoting the hexadecimal 
representation of a nonnegative
integer.

**Examples:**

----
1234
0xABCD
----

=== Floating-Point Literals

A *floating-point literal expression* is a C-style representation of an
IEEE floating-point number.

**Examples:**

----
1e-10
0.001
3.14159
6.02E23
----


=== Boolean Literals

A *Boolean literal expression* is one of the values `true` and `false`.

=== Arithmetic Expressions

FPP currently includes the following *arithmetic expressions*:

[cols=",",options="header",]
|======================================
|Syntax
|Meaning

|`-` stem:[e]
|Negate stem:[e]

|======================================

For unary negation expressions, `-` stem:[e] must be
a <<Types_Integer-and-Numeric-Types,numeric type>>.

=== Identifier Expressions

An *identifier expression* is an
<<Lexical-Elements_Identifiers,identifier>>
that refers to a
<<Definitions_Constant-Definitions,constant definition>>
or
<<Definitions_Enumerated-Constant-Definitions,enumerated constant definition>>, 
according to the 
<<Scoping-of-Names_Resolution-of-Identifiers,rules for resolving identifiers>>.

**Example:**

[source,fpp]
----
constant a = 42
constant b = a # a is an identifier expression
----

=== Dot Expressions

A *dot expression* is a
<<Definitions-and-Uses_Uses,use>>
that refers to a
<<Definitions_Constant-Definitions,constant definition>>
or
<<Definitions_Constant-Definitions,enumerated constant definition>>.

==== Syntax

<<Expressions,_expression_>>
`.`
<<Lexical-Elements_Identifiers,_identifier_>>

==== Semantics

The following rules give the meaning of a dot expression stem:[e]`.x`:

.  If stem:[e]`.x` is a
<<Scoping-of-Names_Qualified-Identifiers,qualified
identifier>> that represents one of the uses listed above according to
the
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,rules
for resolving qualified identifiers>>, then it evaluates to the value
stored in the corresponding <<Definitions,definition>>.

.  Otherwise stem:[e]`.x` is invalid.

==== Examples

===== Example 1

[source,fpp]
----
namespace N {
  constant a = 1
}
constant b = N.a # N.a evaluates to 1
----

===== Example 2

[source,fpp]
----
enum E { X = 0, Y = 1 }
constant a = E.X # E.X evaluates to 0
----

=== Precedence and Associativity

==== Precedence

Ambiguity in parsing expressions is resolved with the following
precedence ordering. Expressions appearing earlier in the ordering
have higher precedence. For example, `-a.b` is parsed as `-(a.b)`
and not `(-a).b`.

* Dot expressions _e_ `.` _e_.

* Unary minus expressions `-` _e_.

==== Associativity

For the current expression grammar, no associativity rules are required.
