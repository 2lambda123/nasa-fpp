== Expressions

=== Integer Literals

An *integer literal expression* is one of the following:

* A sequence of decimal digits `0` through `9` denoting the decimal
representation of a nonnegative integer.

* `0x` or `0X` followed by a sequence of hexadecimal digits
`0` through `9`, `A` through `F`, or `a` through `f` denoting the hexadecimal 
representation of a nonnegative
integer.

An integer literal value stem:[v] must be representable as an unsigned
integer using most 64 bits, i.e., it must lie in the range stem:[0 <= v < 2^64].

**Examples:**

[source,fpp]
----
1234
0xABCD
----

=== Floating-Point Literals

A *floating-point literal expression* is a C-style representation of an
IEEE floating-point number.

**Examples:**

[source,fpp]
----
1e-10
0.001
3.14159
6.02E23
----

=== Boolean Literals

A *Boolean literal expression* is one of the values `true` and `false`.


=== String Literals

A *string literal expression* is a sequence of characters enclosed in double quotes.
The characters must be printable ASCII characters, and the double
quote character itself is not allowed.

*Examples:*

* `"abc"` is a valid string representing the characters `a`, `b`, and `c`.

* `"abc` is not a valid string, because it is missing the terminating double quote.

* `"ab"c"` is the valid string `"ab"` followed by the identifier `c` and an 
unmatched double quote character.

=== Array Expressions

An *array expression* is an expression that represents an array value.

==== Syntax

`[` _array-element-sequence_ `]`

_array-element-sequence_ is an
<<Element-Sequences,element sequence>> in which the elements
are
<<Expressions,expressions>>, and the terminating punctuation
is a comma.

==== Semantics

. The sequence must have at least one element.

. The types of the expressions in the sequence must be
<<Type-Checking_Computing-a-Common-Type_Lists-of-Types,
convertible to a common type>>.

. The value of the expression is formed by computing
the value of each element and then converting all the
elements to the common type.

==== Example

[source,tnet]
----
constant a = [ 0, 1, 2 ] # a is an array value of with elements 0, 1, 2
----

=== Struct Expressions

An *struct expression* is an expression that represents a struct value.

==== Syntax

`{` _struct-element-sequence_ `}`

_struct-element-sequence_ is an
<<Element-Sequences,element sequence>> in which the elements
are struct elements.
A *struct element* has the following syntax:

<<Lexical-Elements_Identifiers,_identifier_>> `=` <<Expressions,_expression_>>

==== Semantics

The following must be true of the struct element sequence _S_:

. No two identifiers appearing in _S_ may be the same.

. Each expression appearing in _S_ must have a valid type.

The expression is evaluated by evaluating each member expression
to a value and then constructing the struct value with the
corresponding member names and values.

==== Example

[source,fpp]
----
# s is a struct value with members x = 0, y = 1
constant s = { 
  x = 0
  y = 1
}
----

=== Arithmetic Expressions

FPP includes the following *arithmetic expressions*:

[cols=",",options="header",]
|======================================
|Syntax
|Meaning

|`-` stem:[e]
|Negate stem:[e]

|stem:[e_1] `+` stem:[e_2]
|Add stem:[e_1] and stem:[e_2]

|stem:[e_1] `-` stem:[e_2]
|Subtract stem:[e_2] from stem:[e_1]

|stem:[e_1] `*` stem:[e_2]
|Multiply stem:[e_1] by stem:[e_2]

|stem:[e_1] `/` stem:[e_2]
|Divide stem:[e_1] by stem:[e_2]

|======================================

Each subexpression of an arthmetic expression must have
<<Types_Internal-Types_Numeric-Types,numeric type>>.
For binary aritmetic expressions, the type of the whole expression is the
<<Type-Checking_Computing-a-Common-Type,common type>> of the subexpressions.
The arithmetic is either standard integer arithmetic or standard floating-point 
arithmetic, depending on the type.

*Example:*

[source,fpp]
----
constant a = -1
constant b = 2 + 3
constant c = a * b
----

=== Identifier Expressions

An *identifier expression* is an
<<Lexical-Elements_Identifiers,identifier>>
that refers to a
<<Definitions_Constant-Definitions,constant definition>>
or
<<Definitions_Enumerated-Constant-Definitions,enumerated constant definition>>, 
according to the 
<<Scoping-of-Names_Resolution-of-Identifiers,rules for resolving identifiers>>.

**Example:**

[source,fpp]
----
constant a = 42
constant b = a # a is an identifier expression
----

=== Dot Expressions

A *dot expression* is a
<<Definitions-and-Uses_Uses,use>>
that refers to a
<<Definitions_Constant-Definitions,constant definition>>
or
<<Definitions_Constant-Definitions,enumerated constant definition>>.

==== Syntax

<<Expressions,_expression_>>
`.`
<<Lexical-Elements_Identifiers,_identifier_>>

==== Semantics

The following rules give the meaning of a dot expression stem:[e]`.x`:

.  If stem:[e]`.x` is a
<<Scoping-of-Names_Qualified-Identifiers,qualified
identifier>> that represents one of the uses listed above according to
the
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,rules
for resolving qualified identifiers>>, then it evaluates to the value
stored in the corresponding <<Definitions,definition>>.

.  Otherwise stem:[e]`.x` is invalid.

==== Examples

===== Example 1

[source,fpp]
----
module M {
  constant a = 1
}
constant b = M.a # M.a evaluates to 1
----

===== Example 2

[source,fpp]
----
enum E { X = 0, Y = 1 }
constant a = E.X # E.X evaluates to 0
----

=== Parenthesis Expressions

A *parenthesis expression* is an expression surrounded
by parentheses in order to group subexpressions and to
force evaluation order.

==== Syntax

`(`
<<Expressions,_expression_>>
`)`

==== Semantics

The type and value of the expression are the type and value of the subexpression.

==== Example

[source,fpp]
----
constant a = (1 + 2) * 3
----

=== Precedence and Associativity

Ambiguity in parsing expressions is resolved with the following
precedence table. Expressions appearing earlier in the table
have higher precedence. For example, `-a.b` is parsed as `-(a.b)`
and not `(-a).b`. Where necessary, each element in the ordering provides an 
associativity for resolving expressions with equal precedence.

[cols=",",options="header",]
|======================================

|Expression
|Associativity

|Dot expressions stem:[e] `.` stem:[i]
|None

|Unary negation expressions `-` stem:[e]
|None

|Multiplication expressions stem:[e_1] `*` stem:[e_2] and division expressions stem:[e_1] `/` stem:[e_2]
|Left

|Addition expressions stem:[e_1] `+` stem:[e_2] and subtraction expressions stem:[e_1] `-` stem:[e_2]
|Left

|======================================

