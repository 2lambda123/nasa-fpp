== Type Checking

In this section, we explain the rules used to assign types to
expressions. FPP is a statically typed language. That means the
following:

* Type checking of expressions occurs during <<Translation,translation>>.

* If the type checking phase detects a violation of any of these rules,
then translation halts with an error message and does not produce any
code.

Each type represents a collection of
<<Evaluation_Values,values>>.
The type checking rules exist to ensure that whenever an expression of
type stem:[T] is <<Evaluation_Evaluating-Expressions,evaluated>>,
the result is a value of type stem:[T].

=== Internal Types

Internal types do not appear in FPP source models.
The compiler assigns these types to expressions during type checking.

==== Integer

The type _Integer_ represents all integer values, without regard
to bit width.

==== Integer Types

<<Type-Checking_Internal-Types_Integer,_Integer_>> together with the 
<<Types_Primitive-Types,primitive integer types>> are called
the *integer types*.

==== Numeric Types

<<Type-Checking_Internal-Types_Integer,_Integer_>> together with the 
<<Types_Primitive-Types,primitive numeric types>> are called
the *numeric types*.

=== Integer Literals

To type an
<<Expressions_Integer-Literals,integer
literal expression>>, the semantic analyzer does the following:

. Evaluate the expression to an unsigned integer value stem:[v].

. Check that stem:[v] can be represented in 64 or fewer bits. If not, throw
an error.

. Assign the type <<Type-Checking_Internal-Types_Integer,_Integer_>> to the expression.

**Examples:**

[source,fpp]
----
constant a = 0 # Type is Integer
constant b = 1 # Type is Integer
constant c = 256 # Type is Integer
constant d = 65536 # Type is Integer
constant e = 0x100000000 # Type is Integer
constant f = 0x10000000000000000 # Error; integer value is too large
----

=== Floating-Point Literals

The type of a
<<Expressions_Floating-Point-Literals,floating-point
literal expression>> is `F64`.

=== Boolean Literals

The type of a
<<Expressions_Boolean-Literals,boolean
literal expression>> is `bool`.

=== String Literals

The type of a
<<Expressions_String-Literals,string
literal expression>> is `string`.

=== Array Expressions

To type an
<<Expressions_Array-Expressions,array expression>>
stem:[T] `[` stem:[e_1] `,` stem:[...] `,` stem:[e_n] `]`,
the semantic analyzer does the following:

. Check that the qualified identifier stem:[Q] refers to an
<<Definitions_Array-Types-Definition,array type definition>> stem:[D] with 
element type stem:[T'].

. For each stem:[i in [1,n]]

.. Compute the type stem:[T_i] of stem:[e_i]

.. Check that stem:[T_i] is <<Type-Checking_Type-Conversion,convertible to>>
stem:[T']

. Assign the type associated with stem:[D] to the expression.

=== Struct Expressions

TODO

=== Unary Minus

To type a
<<Expressions_Arithmetic-Expressions,unary
minus expression>> `-` stem:[e], the semantic analyzer does the following:

. Compute the type stem:[T] of stem:[e].

. If stem:[T] is a 
<<Types_Primitive-Types,primitive numeric type>>
or stem:[T] is
<<Type-Checking_Internal-Types_Integer,_Integer_>>,
then use stem:[T].

. Otherwise throw an error.

**Examples:**

[source,fpp]
----
constant b = -1.0 # Type is F64
constant c = -1 # Type is Integer
constant d = -c # Type is Integer
constant e = -0xFFFFFFFF # Type is Integer
constant f = -bool # Error
----

=== Identifier Expressions

To type an <<Expressions_Identifier-Expressions,identifier 
expression>> stem:[e], the semantic analyzer 
<<Scoping-of-Names_Resolution-of-Identifiers,resolves the identifier to a 
definition>> and uses the type given in the definition.

**Example:**

[source,fpp]
----
constant a = 42 # a is a constant with type Integer
constant b = a # The expression a refers to the constant a and has type Integer
----

=== Dot Expressions

To type a
<<Expressions_Dot-Expressions,dot
expression>> stem:[e] `.x`, the semantic analyzer does the following:

. If stem:[e]`.x` is a
<<Scoping-of-Names_Qualified-Identifiers,qualified identifier>> that represents 
the use of a definition according to the
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,rules
for resolving qualified identifiers>>, and the use is a valid
<<Expressions_Dot-Expressions,dot
expression>>, then use the type given in the definition.

. Otherwise stem:[e]`.x` is invalid. Throw an error.

**Example:**

[source,fpp]
----
module M { 
  constant a = 0 # The constant M.a has type Integer
}
constant b = M.a # Expression M.a represents a use of the definition M.a.
                 # Its type is Integer.
----

=== Type Conversion

We say that a type stem:[T_1] *may be converted to* another type stem:[T_2] if
every <<Evaluation_Values,value>> represented by type stem:[T_1] can be
<<Evaluation_Type-Conversion,converted>> into a value of type stem:[T_2].

Here are the rules for type conversion:

. Any <<Type-Checking_Internal-Types_Numeric-Types,numeric
type>> may be converted to any other numeric type.

. An <<Types_Enum-Types,enum type>> may be converted to a
<<Type-Checking_Internal-Types_Numeric-Types,numeric type>>.

. A type stem:[T_1] may be converted to an
<<Types_Array-Types,array type>> stem:[T_2] if
stem:[T_1] may be converted to the member type of stem:[T_2].

. A type stem:[T_1] may be converted to a
<<Types_Structure-Types,structure type>> stem:[T_2] if
for each member stem:[m_{2i}] `:` stem:[T_{2i}] of 
stem:[T_1] may be converted to stem:[T_{2i}].

. Type convertibility is transitive: if stem:[T_1] may be converted to 
stem:[T_2]
and stem:[T_2] may be converted to stem:[T_3], then stem:[T_1] 
may be converted to stem:[T_3].
