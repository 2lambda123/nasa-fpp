== Evaluation

*Evaluation* is the process of transforming an <<Expressions,expression>> into 
a <<Evaluation_Values,value>>.
In FPP, all evaluation happens during
<<Analysis-and-Translation_Analysis,analysis>>,
in resolving expressions to compile-time constant values.

=== Values

A *value* is one of the following:

* A primitive integer value

* An integer value

* A floating-point value

* A Boolean value

* A string value

* An anonymous array value

* An array value

* An enumeration value

* An anonymous struct value

* A struct value

Every value belongs to exactly one type.

==== Primitive Integer Values

A *primitive integer value* is an ordinary (mathematical) integer value 
together with a
<<Types_Primitive-Integer-Types,primitive integer type>>. Formally, the set of 
primitive integer values
is the disjoint union over the integer types of the values
represented by each type:

* An unsigned integer type of width stem:[w] represents integers in the 
range stem:[[0, 2^w-1\]]. For example, `U8` represents the integers 
stem:[[0, 255\]].

* A signed integer type of width stem:[w] represents integers in the range
stem:[[-2^(w-1), 2^(w-1)-1\]]. For example, `I8` represents the integers
stem:[[-128, 127\]].

We represent a primitive integer value as an expression followed by a colon and a type.
For example, we write the value 1 at type `U32` as `1 : U32`. The value `1 :
U32` is distinct from the value `1 : U8`.

==== Integer Values

An *integer value* is an ordinary (mathematical) integer value.
It has type _Integer_.
We represent an integer value as an integer number, with no explicit type.
For example, `1` is an integer value.

==== Floating-Point Values

A *floating-point value* is an IEEE floating-point value of 4- or 8-byte
width. Formally, the set of floating-point values is the disjoint union
over the types `F32` and `F64` of the values represented by each type:

* The type `F32` represents all IEEE 4-byte floating-point values.

* The type `F64` represents all IEEE 8-byte floating-point values.

We write a floating-point values analogously to primitive integer values. For 
example, we write the value 1.0 at type `F32` as `1.0 : F32`.

==== Boolean Values

A *Boolean value* is one of the values `true` and `false`.
Its type is `bool`.

==== String Values

A *string value* is a sequence of characters that can be
represented as a <<Expressions_String-Literals,string literal expression>>.
It is written in the same way as a string literal expression,
e.g., `"abc"`.
Its type is `string`.

==== Anonymous Array Values

An *anonymous array value* is a value associated with an anonymous
array type.
We write an anonymous array value similarly to an
<<Expressions_Array-Expressions,array expression>>:
an anonymous array value has the form `[` stem:[v_1] `,` stem:[...] `,` 
stem:[v_n] `]`, where for each stem:[i in [1,n]], stem:[v_i] is a value of type 
stem:[T] for some stem:[T].
The type of the value is _[_ stem:[n] _]_ stem:[T].

==== Array Values

An *array value* is a value associated with an array type.
We write an array value like an <<Evaluation_Values_Anonymous-Array-Values,anonymous array 
value>>, except that the value is annotated with an
<<Types_Array-Types,array type>>.

<<Expressions_Array-Expressions,array expression>>:
an array value has the form `[` stem:[v_1] `,` stem:[...] `,` 
stem:[v_n] `]` `:` stem:[Q],
where

. stem:[Q] is a
<<Scoping-of-Names_Qualified-Identifiers,qualified identifier>>
that refers to a
<<Definitions_Array-Definitions,array definition>>
with member type stem:[T].

. For each stem:[i in [1,n]], stem:[v_i] is a value of type stem:[T].

The type of the value is stem:[Q].

==== Enumeration Values

An *enumeration value* is a value associated with an
<<Definitions_Enumerated-Constant-Definitions,enumerated constant definition>>.
Its type is the type associated with the
<<Definitions_Enum-Definitions,enum definition>> in which
the enumerated constant definition appears.

==== Anonymous Struct Values

An *anonymous struct value* is a value associated with an
<<Types_Internal-Types_Anonymous-Struct-Types,anonymous struct
type>>.
We write an anonymous struct value stem:[v] similarly to a
<<Expressions_Struct-Expressions,struct expression>>:
a struct value has the form `{` stem:[m_1] `=` stem:[v_1] `,` stem:[...] `,` 
stem:[m_n] `=` stem:[v_n] `}`,
where for each stem:[i in [1,n]], stem:[v_i] is a value of type stem:[T_i].
The type of stem:[v] is _{_ stem:[m_1] _:_ stem:[T_1] _,_ stem:[...] _,_
stem:[m_n] _:_ stem:[T_n] _}_.

==== Struct Values

A *struct value* is a value associated with a
<<Types_Struct-Types,struct type>>.
that is an element of a struct type.
We write a struct value similarly to an
<<Evaluation_Values_Struct-Values,anonymous struct value>>,
except that we annotate the value with a struct type:
a struct value has the form `{` stem:[m_1] `:` stem:[v_1] `,` stem:[...] `,` 
stem:[m_n] `:` stem:[v_n] `}` `:` stem:[Q],
where

. stem:[Q] is a
<<Scoping-of-Names_Qualified-Identifiers,qualified identifier>>
that refers to a
<<Definitions_Struct-Definitions,struct definition>>.

. The members of stem:[Q] are stem:[m_i] `:` stem:[T_i] for stem:[i in [1,n\]].

. For each stem:[i in [1,n]], stem:[v_i] is a value of type stem:[T_i].

All the members must be explicitly assigned values.

=== Evaluating Expressions

Evaluation of expressions occurs as stated in the
<<Expressions,expression descriptions>>. Evaluation of integer
expressions occurs at type 
<<Types_Internal-Types_Integer,_Integer_>>,
using enough bits to represent the result without overflow.
Evaluation of floating-point expressions occurs using 64-bit arithmetic.

=== Type Conversion

The following rules govern the conversion of a value stem:[v_1] of type 
stem:[T_1]
to a value stem:[v_2] of type stem:[T_2].

==== Unsigned Primitive Integer Values

. If stem:[T_1] and stem:[T_2] are both unsigned primitive integer types and 
stem:[T_2] is
narrower than stem:[T_1], then construct stem:[v_2] by truncating the 
unsigned
binary representation of stem:[v_1] to the width of stem:[v_2]. For 
example, converting `0x1234 : U16` to `U8` yields `0x34 : U8`.

. Otherwise if stem:[T_1] and stem:[T_2] are both unsigned primitive integer 
types, then
stem:[v_2] is the integer value of stem:[v_1] at the type of 
stem:[v_2]. For example,
converting `0x12 : U8` to `U16` yields `0x12 : U16`.

==== Signed Primitive Integer Values

. If stem:[T_1] and stem:[T_2] are both signed primitive integer types and
stem:[T_2] is narrower than stem:[T_1], then construct stem:[v_2] by truncating
the two's complement binary representation of stem:[v_1] to the width of
stem:[v_2]. For example, converting `-0x1234 : I16` to `I8` yields `-0x34 :
I8`.

. Otherwise if stem:[T_1] and stem:[T_2] are both signed primitive integer 
types, then stem:[v_2]
is the integer value of stem:[v_1] at the type of stem:[v_2]. For 
example, converting `-0x12 : I8` to `I16` yields `-0x12 : I16`.

==== Primitive Integer Values of Mixed Sign

If stem:[T_1] and stem:[T_2] are primitive integer types with one signed and 
one unsigned,
then do the following:

. Construct the value stem:[v] by converting stem:[v_1] to the type 
stem:[T], where
stem:[T] is signed if stem:[T_1] is signed and unsigned if 
stem:[T_1] is unsigned, and
stem:[T] has the same width as stem:[T_2].

. Construct stem:[v_2] by converting stem:[v] to stem:[T_2].

For example converting `-1 : I8` to `U16` yields `0xFFFF : U16`

==== Primitive and Non-Primitive Integer Values

If stem:[T_1] is _Integer_ and stem:[T_2] is a primitive integer type, then
proceed as if stem:[T_1] were a signed primitive integer
type of the narrowest bit width that will hold stem:[v_1].
For example, converting `-0x1234` to `I8` yields `-0x34 : I8`.

If stem:[T_1] is a primitive integer type and stem:[T_2] is
_Integer_, then stem:[v_2] is the integer value of stem:[v_1]
at type _Integer_. For example, converting
`0xFFFF : U32` to _Integer_ yields `0xFFFF`.

==== Floating-Point Values

We use the standard rules for IEEE floating-point values to convert
among integer values to and from floating-point values and
floating-point values to and from each other.

==== Array Values

If stem:[T_2] is an array type and stem:[T_1 = T_2], then
let stem:[v_2 = v_1].

Otherwise if stem:[T_1] is an anonymous array type and stem:[T_2] is an 
anonymous array type or array type, both with stem:[n] elements, then

. Let stem:[T'_2] be the element type of stem:[T_2].

. For each stem:[i in [1,n\]], stem:[v'_i] be the result of converting stem:[v_i] to type stem:[T'_2].

. Let stem:[v_2] be the unique array value of type stem:[T_2]
with value stem:[v'_i] at each element.

Otherwise the conversion is not valid.

==== Structure Values

If stem:[T_2] is a struct type and stem:[T_1 = T_2], then
let stem:[v_2 = v_1].

Otherwise if stem:[T_1] is an anonymous struct type and stem:[T_2] is
an anonymous struct type or struct type
such that for each member stem:[m] `:` stem:[v_m] of stem:[T_1] there is a member 
stem:[m] `:` stem:[T_m] in stem:[T_2], then use the value of stem:[T_2] with 
the following members:

. For each member stem:[m] `:` stem:[T_m] of stem:[T_2] such that there is a member 
stem:[m] `:` stem:[v_m] in stem:[v_1], add the member stem:[m] `:` stem:[v'_m],
where stem:[v'_m] is the result of converting stem:[v_m] to stem:[T_m].

. For each member stem:[m] `:` stem:[T_m] of stem:[T_2] such that there is no member 
stem:[m] `:` stem:[v_m] in stem:[v_1], add the member stem:[m] `:` stem:[v'_m],
where stem:[v'_m] is the <<Types_Default-Values,default value>> at type stem:[T_m].

Otherwise the conversion is invalid.
