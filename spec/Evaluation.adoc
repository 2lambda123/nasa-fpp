== Evaluation

*Evaluation* is the process of transforming an <<Expressions,expression>> into 
a <<Evaluation_Values,value>>.
In FPP, all evaluation happens during
<<Translation,translation>>,
in resolving expressions to compile-time constant values.

=== Values

A *value* is one of the following:

* An integer value.

* A floating-point value.

* A Boolean value.

* A string value.

* An enumeration value.

Every value belongs to exactly one type.

==== Integer Values

An *integer value* is an ordinary (mathematical) integer value together
with an
<<Types_Integer-and-Numeric-Types,integer type>>. Formally, the set of integer values
is the disjoint union over the integer types of the values
represented by each type:

* An unsigned integer type of width stem:[w] represents integers in the 
range stem:[[0, 2^w-1\]]. For example, `U8` represents the integers 
stem:[[0, 255\]].

* A signed integer type of width stem:[w] represents integers in the range
stem:[[-2^(w-1), 2^(w-1)-1\]]. For example, `I8` represents the integers
stem:[[-128, 127\]].

* The _Integer_ type represents integers without regard to bit width.

We represent an integer value as an expression followed by a colon and a type.
For example, we write the value 1 at type `U32` as `1 : U32`. The value `1 :
U32` is distinct from the value `1 : U8`.

==== Floating-Point Values

A *floating-point value* is an IEEE floating-point value of 4- or 8-byte
width. Formally, the set of floating-point values is the disjoint union
over the types `F32` and `F64` of the values represented by each type:

* The type `F32` represents all IEEE 4-byte floating-point values.

* The type `F64` represents all IEEE 8-byte floating-point values.

We write a floating-point values analogously to integer values. For example, we 
write the value 1.0 at type `F32` as `1.0 : F32`.

==== Boolean Values

A *Boolean value* is one of the values `true` and `false`.
Its type is `bool`.

==== String Values

A *string value* is a sequence of characters that can be
represented as a <<Expressions_String-Literals,string literal expression>>.
It is written in the same way as a string literal expression,
e.g., `"abc"`.
Its type is `string`.

==== Enumeration Values

An *enumeration value* is a value associated with an
<<Definitions_Enumerated-Constant-Definitions,enumerated constant definition>>.
Its type is the type associated with the
<<Definitions_Enum-Definitions,enum definition>> in which
the enumerated constant definition appears.

==== Array Values

TODO

==== Structure Values

TODO

=== Evaluating Expressions

Evaluation of expressions occurs as stated in the
<<Expressions,expression descriptions>>. Evaluation of integer
expressions occurs at type _Integer_, using enough bits to
represent the result without overflow.
Evaluation of floating-point expressions occurs using 64-bit arithmetic.

=== Type Conversion

The following rules govern the conversion of a value stem:[v_1] of type 
stem:[T_1]
to a value stem:[v_2] of type stem:[T_2].
Here "fixed-width integer value" means an integer value represented
as a fixed bit width.
All values at primitive integer type are fixed-width integer values.

==== Unsigned Fixed-Width Integer Values

. If stem:[T_1] and stem:[T_2] are both unsigned fixed-width integer types and 
stem:[T_2] is
narrower than stem:[T_1], then construct stem:[v_2] by truncating the 
unsigned
binary representation of stem:[v_1] to the width of stem:[v_2]. For 
example, converting `0x1234 : U16` to `U8` yields `0x34 : U8`.

. Otherwise if stem:[T_1] and stem:[T_2] are both unsigned fixed-width integer 
types, then
stem:[v_2] is the integer value of stem:[v_1] at the type of 
stem:[v_2]. For example,
converting `0x12 : U8` to `U16` yields `0x12 : U16`.

==== Signed Fixed-Width Integer Values

. If stem:[T_1] and stem:[T_2] are both signed fixed-width integer types and
stem:[T_2] is narrower than stem:[T_1], then construct stem:[v_2] by truncating
the two's complement binary representation of stem:[v_1] to the width of
stem:[v_2]. For example, converting `-0x1234 : I16` to `I8` yields `-0x34 :
I8`.

. Otherwise if stem:[T_1] and stem:[T_2] are both signed fixed-width integer 
types, then stem:[v_2]
is the integer value of stem:[v_1] at the type of stem:[v_2]. For 
example, converting `-0x12 : I8` to `I16` yields `-0x12 : I16`.

==== Primitive Integer Values of Mixed Sign

If stem:[T_1] and stem:[T_2] are integer types with one signed and 
one unsigned,
then do the following:

. Construct the value stem:[v] by converting stem:[v_1] to the type 
stem:[T], where
stem:[T] is signed if stem:[T_1] is signed and unsigned if 
stem:[T_1] is unsigned, and
stem:[T] has the same width as stem:[T_2].

. Construct stem:[v_2] by converting stem:[v] to stem:[T_2].

For example, `(-1 : I8) : U16 = 0xFFFF : U16`

==== Fixed-Width and Non-Fixed-Width Integer Values

If stem:[T_1] is _Integer_ and stem:[T_2] is a fixed-width integer type, then
proceed as if stem:[T_1] were a signed fixed-width integer
type of the narrowest bit width that will hold stem:[v_1].
For example, converting `-0x1234 :` _Integer_ to `I8` yields `-0x34 :
I8`.

If stem:[T_1] is a fixed-width integer value and stem:[T_2] is
_Integer_, then stem:[v_2] is the integer value of stem:[v_1]
at type _Integer_. For example, converting
`0xFFFF : U32` to _Integer_ yields `0xFFFF :` _Integer_.

==== Floating-Point Values

We use the standard rules for IEEE floating-point values to convert
among integer values to and from floating-point values and
floating-point values to and from each other.

