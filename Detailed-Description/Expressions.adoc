=== Expressions

==== Integer Literals

An *integer literal expression* is one of the following:

* A sequence of decimal digits `[0-9]` denoting the decimal
representation of a nonnegative integer.
* `0x` or `0X` followed by a sequence of hexadecimal digits
`[0-9A-Fa-f]` denoting the hexadecimal representation of a nonnegative
integer.

An integer literal value stem:[v] must be representable as an unsigned
integer using most 64 bits, i.e., it must lie in the range stem:[0 <= v < 2^64].

===== Examples

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Integer_Literals/Examples_1.tnt[tag=visible]
----

==== Floating-Point Literals

A *floating-point literal expression* is a C-style representation of an
IEEE floating-point number.

===== Examples

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Floating_Point_Literals/Examples_1.tnt[tag=visible]
----

==== Boolean Literals

A *Boolean literal expression* is one of the values `true` and `false`.

===== Examples

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Boolean_Literals/Examples_1.tnt[tag=visible]
----

==== String Literals

A *string literal expression* is a sequence of printable ASCII characters 
enclosed in double quotation marks.
Each character in the expression represents a character of the string,
except for the following character sequences:

* The sequence `\"` represents a quotation mark character.

* The sequence `\\` represents a backslash character.

===== Examples

* The expression `"abc"` represents the character sequence `a`, `b`, `c`.

* The expression `"\"abc\""` represents the character sequence `"`, `a`, `b`, `c`, `"`.

* The expression `"\\abc\\"` represents the character sequence `\`, `a`, `b`, `c`, `\`.

* The expression `"\abc\\"` also represents the character sequence `\`, `a`, `b`, `c`, `\`,
because the sequence `\a` has no special meaning and is translated to the characters
`\`, `a`.

* The expression `"\abc\"` is unterminated (and therefore invalid) because the 
final two
characters `\"` translate to the single character `"` in the sequence, and so 
there is no terminating double quotation mark.

==== Arithmetic Expressions

tnet currently includes the following *arithmetic expressions*, with the
usual precedence rules:

[cols=",",options="header",]
|======================================
|Syntax
|Meaning

|`-` stem:[e]
|Negate stem:[e]

|stem:[e_1] `+` stem:[e_2]
|Add stem:[e_1] and stem:[e_2]

|stem:[e_1] `-` stem:[e_2]
|Subtract stem:[e_2] from stem:[e_1]

|stem:[e_1] `*` stem:[e_2]
|Multiply stem:[e_1] by stem:[e_2]

|stem:[e_1] `/` stem:[e_2]
|Divide stem:[e_1] by stem:[e_2]
|======================================

For unary negation expressions, `-` stem:[e] must have a type stem:[T]
according to the rules for
<<Type-Checking_Unary-Minus,type checking>>.
If stem:[T] is a structure type, then the result is computed by
negating each member of stem:[e].
If stem:[T] is an array type, then the result is computed
negating each element of stem:[e].

For binary arithmetic expressions, stem:[e_1] stem:[op] stem:[e_2]
must have a type stem:[T] according to the rules for 
<<Type-Checking_Binary-Arithmetic-Expressions,type checking>>.
If stem:[T] is a structure type, then the result is computed by applying 
stem:[op] to the corresponding
pairs of members of stem:[e_1] and stem:[e_2].
If stem:[T] is an array type, then the result is
computed by applying stem:[op] to the corresponding
pairs of elements of stem:[e_1] and stem:[e_2].

Floating-point arithmetic occurs according to the rules for IEEE
floating-point numbers. Integer arithmetic occurs according to the
following rules:

.  Carry out the arithmetic using a bit width that is wide enough to
hold the mathematical result. Division means the following:

..  If stem:[a] is zero and stem:[b != 0], then stem:[a] `/` stem:[b] 
evaluates to zero.

..  Otherwise if stem:[b = 0], then throw an error.

..  Otherwise if stem:[a] and stem:[b] have the same sign, then 
stem:[a] `/` stem:[b] evaluates to
stem:[q], where stem:[q] is the largest nonnegative integer such that 
stem:[q|b| <= |a|].

..  Otherwise stem:[a] `/` stem:[b] evaluates to the arithmetic negation of 
stem:[( -a )] `/` stem:[b].

.  If necessary, drop the high-order bits of the result to fit the
width of the expression.

Because of the
<<Type-Checking,typing rules for expressions>>, dropping bits is required only 
where the mathematical result is wider than 64 bits.

==== Logical Expressions

A *logical expression* converts a pair of Boolean values into
a Boolean value.
Currently, the only logical expression available is `and`.

[cols=",",options="header",]
|======================================
|Syntax
|Meaning

|stem:[e_1] `and` stem:[e_2]
|Compute the logical and of stem:[e_1] and stem:[e_2]
|======================================

==== Membership Expressions

A *membership expression* tests for membership in a set.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`in`
<<Detailed-Description_Expressions,_expression_>>

===== Semantics

The first expression must have type _T_, and the second expression
must have type `set` _T_, after type conversion if necessary.
The expression evaluates to `true` if the value represented
by the first expression is a member of the set represented
by the second expression, otherwise `false`.

===== Examples

----
1 in 1            # Evaluates to true
1 in 0..1         # Evaluates to true
1 in set { 0, 1 } # Evaluates to true
1 in set { 0, 2 } # Evaluates to false
----

==== Equality Expressions

An *equality expression* tests two subexpressions for equality.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`=`
<<Detailed-Description_Expressions,_expression_>>

===== Semantics

The two subexpressions must have a
<<Type-Checking_Computing-a-Common-Type,
common type>> _T_.
The expression evaluates to `true` if the value represented
by the first subexpression equals the value represented by
the second subexpression, otherwise false.

===== Examples

----
1 = 1 # Evaluates to true
1 = 2 # Evaluates to false
----

==== Approximation Expressions

An *approximation expression* converts a value _v_ into
a range of values approximating _v_.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`+-`
<<Detailed-Description_Expressions,_expression_>>

===== Semantics

The two subexpressions must have a
<<Type-Checking_Computing-a-Common-Type,
common type>> _T_.
_T_ must be a numeric type.
The expression stem:[e_1] `+-` stem:[e_2] evaluates
to the range `(` stem:[e_1] `-` stem:[e_2] `) .. (` stem:[e_1] `+` stem:[e_2] `)`.

===== Examples

----
1 +- 0.1 # Evaluates to 0.9..1.1
----

==== Structure Expressions

A *structure expression* represents a value of
<<Detailed-Description_Types_Structure-Types,structure type>>, i.e., a data 
structure with members. Each member has a name and a
value. The order of the members appearing in the value is not
significant. Two or more members with the same name are not allowed.

===== Syntax

`{` _structure-member-sequence_ `}`

_structure-member-sequence_ is an
<<Detailed-Description_Element-Sequences,element sequence>> 
in which each element is a structure member of the form
<<Detailed-Description_Identifiers,_identifier_>>
`=`
<<Detailed-Description_Expressions,_expression_>>,
and the terminating punctuation is a comma. _identifier_ is the name of
the member, and _expression_ evaluates to its value.

===== Example

`{ x = 0, y = 1 }` is a structure expression with two members, `x` with
value 0 and `y` with value 1. We can also write this value as follows:

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Structure_Expressions/Example_1.tnt[tag=visible]
----

==== Array Expressions

An *array expression* represents a value of
<<Detailed-Description_Types_Array-Types,array type>>, i.e., an indexed 
collection of values.

===== Syntax

`[` _array-element-sequence_ `]`

_array-element-sequence_ is an
<<Detailed-Description_Element-Sequences,element sequence>> in which each 
element is an expression, and the terminating punctuation is a comma.

===== Examples

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Array_Expressions/Examples_1.tnt[tag=visible]
----

==== Identifier Expressions

An *identifier expression* is an
<<Detailed-Description_Identifiers,identifier>>
that refers to a
<<Detailed-Description_Definitions_Constant-Definitions,constant definition>>,
<<Detailed-Description_Definitions_Constant-Definitions,enumerated constant definition>>, 
or
<<Detailed-Description_Definitions_State-Data-Definitions,state data definition>>. Its 
meaning is given by the
<<Scoping-of-Names_Resolution-of-Identifiers,rules for resolving identifiers>>.

===== Example

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Identifier_Expressions/Example_1.tnt[tag=visible]
----

==== Dot Expressions

A *dot expression* represents one of the following:

.  A
<<Definitions-and-Uses_Uses,use>>
that refers to a
<<Detailed-Description_Definitions_Constant-Definitions,constant definition>>,
<<Detailed-Description_Definitions_Constant-Definitions,enumerated constant definition>>, 
or
<<Detailed-Description_Definitions_State-Data-Definitions,state data definition>>.

.  A member of a
<<Evaluation_Values_Structure-Values,structure value>>.

.  The
<<Evaluation_Values_Range-Values,range value>> or
<<Evaluation_Values_Set-Values,set value>> formed by selecting a member of each 
element of an range or set of structure values.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`.`
<<Detailed-Description_Identifiers,_identifier_>>

===== Semantics

The following rules give the meaning of a dot expression stem:[e]`.x`:

.  If stem:[e]`.x` is a
<<Scoping-of-Names_Qualified-Identifiers,qualified
identifier>> that represents one of the uses listed above according to
the
<<Scoping-of-Names_Resolution-of-Qualified-Identifiers,rules
for resolving qualified identifiers>>, then it evaluates to the value
stored in the corresponding <<Definitions,definitions>>.

.  Otherwise if stem:[e] evaluates to a
<<Evaluation_Values_Structure-Values,structure value>> with a member `x`, then 
stem:[e]`.x` evaluates to the value stored in the member.

.  Otherwise if stem:[e] evaluates to a
<<Evaluation_Values_Range-Values,range value>> stem:[v_1] `..` stem:[v_2] , 
then stem:[e] `.x` evaluates to the range value
stem:[v_1] `.x..` stem:[v_2] `.x` if its elements are valid.

.  Otherwise if stem:[e] evaluates to a
<<Evaluation_Values_Set-Values,set value>> `set {` stem:[v_1] `,` stem:[...] `,` 
stem:[v_n] `}`, then stem:[e] `.x` evaluates to the set
value `set {` stem:[v_1] `.x,` stem:[...] `,` stem:[v_n] `.x` `}` if its 
elements are valid.

.  Otherwise stem:[e]`.x` is invalid.

===== Examples

====== Example 1

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Dot_Expressions/Examples/Example_1_1.tnt[tag=visible]
----

====== Example 2

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Dot_Expressions/Examples/Example_2_1.tnt[tag=visible]
----

====== Example 3

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Dot_Expressions/Examples/Example_3_1.tnt[tag=visible]
----

==== Array Index Expressions

An *array index expression* represents one of the following:

* The value stored at a specified index of an
<<Evaluation_Values_Array-Values,array value>>.

* The <<Evaluation_Values_Rage-Values,range value>> or
<<Evaluation_Values_Set-Values,set value>> formed by selecting the value at a 
specified index of each
element of a range or set of array values.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`[`
<<Detailed-Description_Expressions,_expression_>>
`]`

===== Semantics

The following rules give the meaning of an array index expression
stem:[e_1] `[` stem:[e_2] `]`, where stem:[e_2] evaluates to the 
numeric value stem:[i], interpreted as a `U64` value:

.  If stem:[e_1] evaluates to an
<<Evaluation_Values_Array-Values,array value>> stem:[v], and stem:[i] is a 
valid index for stem:[v], then stem:[e_1] `[` stem:[e_2] `]`
evaluates to the value stored at index stem:[i] of stem:[v].

.  Otherwise if stem:[e_1] evaluates to a
<<Evaluation_Values_Range-Values,range value>> stem:[v_1] `..` stem:[v_2], 
then stem:[e_1] `[` stem:[e_2] `]` evaluates to the range value
stem:[v_1] `[` stem:[i] `]..` stem:[v_2] `[` stem:[i] `]` if its 
elements are valid.

.  Otherwise if stem:[e_1] evaluates to a
<<Evaluation_Values_Set-Values,set value>> `set {` stem:[v_1] `,` stem:[...] `,` 
stem:[v_n] `}`, then stem:[e_1] `[` stem:[e_2] `]` evaluates to
the set value `set {` stem:[v_1] `[` stem:[i] `],` stem:[...] `,` stem:[v_n] 
`[` stem:[i] `]` `}` if its
elements are valid.

.  Otherwise stem:[e_1]`[` stem:[e_2] `]` is invalid.

===== Examples

====== Example 1

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Array_Index_Expressions/Examples/Example_1_1.tnt[tag=visible]
----

====== Example 2

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Array_Index_Expressions/Examples/Example_2_1.tnt[tag=visible]
----

====== Example 3

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Array_Index_Expressions/Examples/Example_3_1.tnt[tag=visible]
----

==== Parenthesis Expressions

A *parenthesis expression* is the usual construct for grouping
subexpressions and enforcing evaluation order.

===== Syntax

`(`
<<Detailed-Description_Expressions,_expression_>>
`)`

===== Semantics

Evaluate `expression` with the indicated evaluation order.

===== Example

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Parenthesis_Expressions/Example/Example_1.tnt[tag=visible]
----

The parenthesis expression forces the evaluation of `+` before the
evaluation of `*`.

==== Explicitly-Typed Expressions

An *explicitly-typed expression* converts a subexpression to a type.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`:`
<<Detailed-Description_Types,_type_>>

===== Semantics

. Evaluate _expression_ to a value stem:[v].

. <<Evaluation,Convert>> stem:[v] to a value of type _type_. The
<<Type-Checking,type of _expression_>> must be 
<<Type-Checking_Type-Conversion,convertible to>> _type_.

====== Example

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Explicitly_Typed_Expressions/Semantics/Example_1.tnt[tag=visible]
----

The expression on the right-hand side of the constant definition
<<Evaluation_Type-Conversion,converts>>
the
<<Type-Checking_Integer-Literals,integer literal 1 with type `U8`>> to type `F32`.

==== Range Expressions

A *range expression* represents a value of
<<Detailed-Description_Types_Range-Types,range type>>,
i.e., all values of a
<<Detailed-Description_Types_Range-Element-Types,range
element type>> that lie between a lower bound and an upper bound.

===== Syntax

<<Detailed-Description_Expressions,_expression_>>
`..`
<<Detailed-Description_Expressions,_expression_>>

===== Semantics

Let stem:[e] be the range expression stem:[e_1] `..` stem:[e_2], 
where stem:[e_1] and stem:[e_2] are
expressions of type stem:[T_1] and stem:[T_2]. Then stem:[T_1] 
and stem:[T_2] must be
<<Type-Checking_Type-Conversion,convertible to a common type stem:[T]>>, 
and stem:[T] must be a
<<Detailed-Description_Types_Range-Element-Types,range element type>>.  
The expression stem:[e] has type `range` stem:[T]. It is evaluated
as follows, where stem:[e_1] evaluates to stem:[v_1] and 
stem:[e_2] evaluates to stem:[v_2]:

* If stem:[T] is a numeric type, then stem:[e] represents all 
values stem:[v] of type stem:[T] such that stem:[v_1 <= v <= v_2].

* If stem:[T] is a structure type `{` stem:[x_1] `:` stem:[T_1] `,`
stem:[...] `,` stem:[x_n] `:` stem:[T_n] `}`,
then stem:[e] represents all structure values `{` stem:[x_1] `=` 
stem:[w_1] `,` stem:[...] `,` stem:[x_n]
`=` stem:[w_n] `}` such that for all stem:[i \in [1,n\]], 
stem:[w_i] is an element of the range stem:[v_1.x_i] `..` stem:[v_2.x_i].

* If stem:[T] is an array type `[` stem:[e'] `]` stem:[T], and 
stem:[e;] evaluates to stem:[n]
after conversion to `U64`, then stem:[e] represents all array values `[` 
stem:[w_0] `,` stem:[...] `,` stem:[w_(n-1)] `]` such that for all stem:[i \in 
[0, n-1\]], stem:[w_i] is an element of the range stem:[v_1] `[` stem:[i] `]..` 
stem:[v_2] `[` stem:[i] `]`.

* If stem:[T] is an enum type, then stem:[e] represents all values
stem:[v] of type stem:[T] such that stem:[v_1 <= v <= v_2],
where the ordering on the values of type stem:[T] is given by the 
numeric values associated with the enumeration constants.

* If stem:[T] is a named type with representation type stem:[T'], then 
<<Evaluation_Type-Conversion_Converting-to-the-Representation-Type,convert>>
stem:[v_1] and stem:[v_2] to values stem:[v'_1] and stem:[v'_2] of type 
stem:[T'] and apply these rules to the range stem:[v'_1] `..` stem:[v'_2].

===== Examples

[source,tnet]
----
include::./Detailed-Description/src/Expressions/Range_Expressions/Examples/Examples_1.tnt[tag=visible]
----

The constant `a` has type `range U8`. The values within this range are
`0` and `1`.

The constant `b` has type `range [2] U8`. This range represents the
values `[ 0, 1 ]`, `[ 0, 2 ]`, `[ 1, 1 ]`, and `[ 1, 2 ]`.

The constant `c` has type `range [2] F64`. This range represents all
values `[` stem:[c_1] `,` stem:[c_2] `]` such that stem:[0.0 <= c_1 <= 1.0] and 
stem:[1.0 <= c_2 <= 2.0].

The constant `d` has type `range { x:U8, y:U8 }`. This range
represents the values `{x=0, y=0}`, `{x=0, y=1}`, `{x=1, y=0}`, and
`{x=1, y=1}`.

The constant `e` has type `range { x:F64, y:F64 }`. This range
represents all values `{ x =` stem:[c_1] `, y =` stem:[c_2] `}` such that 
stem:[0.0 <= c_1 <= 1.0] and stem:[0.0 <= c_2 <= 1.0].

The constant `f` has type `range E` and represents the values
`E.A`, `E.B`, and `E.C`.

==== Set Expressions

A *set expression* represents a value of
<<Detailed-Description_Types_Set-Types,set type>>, i.e., a set of point values 
and ranges of
<<Detailed-Description_Types_Set-Element-Types,set
element type>>.

===== Syntax

`set {` _set-element-sequence_ `}`

_set-element-sequence_ is an
<<Detailed-Description_Element-Sequences,element sequence>> in which each 
element is an expression, and the terminating punctuation is a comma.

===== Semantics

Each expression in the set element sequence must evaluate to a single
value of set element type or a range of values of set element
type. The overall expression represents the union of all the elements
represented by the single values and ranges.

====== Examples

* `set { 0..3, 5, 10 }` represents the following mathematical set of U8
values: stem:[\{ 0, 1, 2, 3, 5, 10 \}].
* `set { 0.0..1.0, 10.0 }` represents the following mathematical set of
`F64` values: stem:[\{ x : 0.0 <= x <= 1.0 \} uu \{ 10.0 \}].

==== Precedence and Associativity

===== Precedence

Ambiguity in parsing expressions is resolved with the following
precedence ordering. Expressions appearing earlier in the ordering
have higher precedence. For example, `1 + 2 * 3` is parsed as `1 + (2 * 3)`
and not `(1 + 2) * 3`.

* Dot expressions _e_ `.` _e_.

* Array index expressions _e_ `[` _e_ `]`.

* Unary minus expressions `-` _e_.

* Range expressions _e_ `..` _e_.

* Explicitly typed expressions _e_ `:` _t_.

* Multiplication expressions _e_ `*` _e_ and division expressions _e_ `/` _e_.

* Addition expressions _e_ `+` _e_ and subtraction expressions _e_ `-` _e_.

* Approximation expressions _e_ `+-` _e_.

* Membership expressions _e_ `in` _e_.

* Equality expressions _e_ `=` _e_.

* Logical expressions _e_ `and` _e_.

===== Associativity

Wherever necessary to resolve ambiguity, operators are left associative.
For example, `a = b = c` is parsed as `(a = b) = c` and not `a = (b = c)`.
