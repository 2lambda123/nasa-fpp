== Specifying Models

The previous sections have explained the various syntactic elements
of FPP.
This section takes a broader view:
it explains how to assemble the elements into an FPP model.

In the discussion below

* We focus on constants and types, because those 
elements of FPP are currently implemented.
In future versions of this User's Guide, we will extend the discussion to cover
ports, components, and topologies.

* We discuss several tools for specifying and analyzing dependencies between
model files.
Here we focus on how to use the tools, and we summarize their most important
features.
We do not attempt to cover every feature of every tool.
For more comprehensive coverage, see
https://github.jpl.nasa.gov/bocchino/fpp/wiki/Tools[the FPP wiki].

=== Dividing Models into Files

Unlike F Prime XML, FPP does not require any particular division of model 
elements into files.
For example, there is no requirement that each
type definition reside in its own file.
Nor is there any requirement that the names of files correspond
to the names of the definitions in the files.

Of course you should try to adhere to good style when decomposing a large model 
into many files.
For example:

* Group related model elements into files, and name the files
according to the purpose of the grouping.

* Choose meaningful module names, and group all files in a single module
in single directory (including its subdirectories).
Examples from the F Prime distribution include the `Fw` and `Svc`
namespaces, which correspond to modules `Fw` and `Svc` in an FPP model.

* Group files into modules and directories logically according to their function.
For example:

** You can group files according to their role in the FPP model.
For example, group types separately from ports.

** You can group files according to their role in the FSW.
For example, group framework files separately from application files.

There is a requirement that a syntactic unit must begin and end in the same file.
For example:

* Each type definition is a syntactic unit, so each type definition must begin 
and end in the same file.

* A module definition may span several syntactic units of the form 
`module { ...  }`,
so a module definition may span multiple files (with each unit of the form
`module { ... }` residing in a single file).

These rules are similar to the way that {cpp} requires a class definition
`class C { ... }` or a namespace block `namespace N { ... }` to reside in a 
single file, but it allows the definition of a single namespace `N` to span 
multiple blocks
`namespace N { ... }` that can be in different files.

=== Dependencies

When a model is split into two or more files, a file _f_ may use symbols
whose definitions appear in files other than _f_.
In order to analyze and translate _f_, the analyzer needs to extract
the definitions from these files, called the *dependencies* of _f_.

For example, suppose the file `a.fpp` contains the following definition:

[source,fpp]
----
constant a = 0
----

And suppose the file `b.fpp` contains the following definition:


[source,fpp]
--------
constant b = a
--------

If you present both files to `fpp-check`, like this:

----
% fpp-check a.fpp b.fpp
----

the check will pass.
However, if you present just `b.fpp`, like this:

----
% fpp-check b.fpp
----

you will get an error stating that the symbol `a` is undefined. (Try it and 
see.)
The error occurs because the definition of `a` is located in `a.fpp`,
which was not included in the analysis.

For very simple models, we can easily manage the dependencies by hand, as we 
did for the example above.
However, for even moderately complex models, this kind of hand management 
becomes difficult.
Therefore FPP has a set of tools and features that help automate dependency
management.

In summary, dependency management in FPP works as follows:

. You run a tool called `fpp-locate-defs` to generate *location specifiers*
for all the symbols that could be used in _f_.

. You run a tool called `fpp-depend`, passing it _f_ and the location 
specifiers
generated in step 1.
It emits a list of files containing the symbols used in _f_ (i.e., the 
dependencies of _f_).

Typically these steps occur in separate phases of development.
For example:

* You may run step 1 to locate and export all the type definitions
on which your model depends.

* You may run step 2 to develop ports that depend on the types.

Below we explain these steps in more detail.

=== Location Specifiers

This section explains how location specifiers work.

==== The Form of a Location Specifier

A location specifier is a unit of syntax in an FPP model.
Here we explain the syntax, so you know what it means.
However, you should ordinarily not write location specifiers
by hand.
Instead, you should let the tools generate them, as described
in the next section.

*Syntax:* A location specifier consists of the keyword `locate`, a kind of symbol,
the name of a symbol, and a string representing a file path.
For example, to locate the definition of constant `a` at `a.fpp`,
we would write

[source,fpp]
----
# Locating a constant definition
locate constant a at "a.fpp"
----

For the current version of FPP, the kind of symbol can be `constant` or `type`.
To locate a type `T` in a file `T.fpp`, we would write the following:

[source,fpp]
----
# Locating a type definition
locate type T at "T.fpp"
----

To locate an enum, we locate the type; the location of the enumerated
constants are then implied:

[source,fpp]
----
# Locating an enum definition,
# including the enumerated constant definitions
locate type E at "E.fpp"
----

*Path Names:* The path name in a location specifier _L_ is relative to the
location of the file where _L_ appears.
For example, suppose the file `b.fpp` appears on the file system in some directory _D_.
Suppose also that _D_ has a subdirectory `Constants`, `Constants` contains a file `a.fpp`,
and `a.fpp` defines the constant `a`.
Then in `b.fpp` we could write this:

[source,fpp]
----
locate constant a at "Constants/a.fpp"
----

If, instead of residing in a subdirectory, `a.fpp` were located one directory above
`b.fpp` in the file system, we could write this:

[source,fpp]
----
locate constant a at "../a.fpp"
----

*Symbol Names:* The symbol name appearing after the keyword `locate`
may be a qualified name.
For example, suppose the file `M.fpp` contains the following:

[source,fpp]
----
module M { constant a = 0 }
----

Then in file `b.fpp` we could write this:

[source.fpp]
----
locate constant M.a at "M.fpp"
----

Optionally, we may enclose the locate specifier in the module `M`, like
this:

[source,fpp]
----
module M { locate constant a at "M.fpp" }
----

A locate specifier written inside a module this way has its symbol name
implicitly qualified with the module name.
For example, the name `a` appearing in the example above is automatically
resolved to `M.a`.

Note that this rule is less flexible than for other uses of definitions.
For example, when using the constant `M.a` in an expression inside module `M`
you may spell the constant either `a` or `M.a`;
but when referring to the same constant `M.a` in a locate specifier in module 
`M`, you must write `a` and not `M.a`.
The purpose of this restriction is to facilitate dependency analysis,
which occurs before the analyzer has complete information about
definitions and their uses.

==== Generating Location Specifiers

The FPP tool suite provides two ways to generate location specifiers:

. Given a collection of FPP source files _F_, you can generate location specifiers 
for
all the symbols defined in _F_.
The tool for doing this is called `fpp-locate-defs`.

. Given a collection of location specifiers _L_, and given one 
or more files _F_ that depend on the symbols located in _L_, you can generate
the subset of _L_ corresponding to the symbols used in the files.
The tool for doing this is called `fpp-locate-uses`.

As example, you could carry out step 1 to report the locations of all
the type definitions in your model.
Later, you could carry out step 2 to report the locations of all the type 
definitions used in a port definition.

*Locating Definitions:* To locate definitions, do the following:

. Collect all the FPP source files containing the definitions you want to 
locate.
For example, run `find . -name '*.fpp'`.

. Run `fpp-locate-defs` with the result of step 1 as the command-line 
arguments.
The result will be a list of location specifiers.

For example, suppose the file `Constants/a.fpp` defines the constant `a`.
Running

----
% fpp-locate-defs `find Constants -name '*.fpp'`
----

generates the location specifier

[source,fpp]
----
locate constant a at "Constants/a.fpp"
----

Notice that the location path is relative to the current directory.
To specify a different base directory, use the option `-d`.
For example, running

----
% fpp-locate-defs -d Constants `find Constants -name '*.fpp'`
----

generates the location specifier

[source,fpp]
----
locate constant a at "a.fpp"
----


*Locating Uses:* To locate uses, do the following:

. Construct a comma-separated list _F1_ of one or more FPP source files 
containing location specifiers.
These files could be the output of *locating definitions*, above.

. Construct a space-separated list _F2_ one or more FPP source files whose uses you want to locate.

. Run `fpp-locate-uses -i` _F1_ _F2_

The `-i` option stands for _import_: it says that the files _F1_ are to be read 
for their
symbols, but not to be included in the results of the analysis.

For example, suppose `a.fpp` defines constant `a`, `b.fpp` defines constant 
`b`,
and `c.fpp` uses `a` but not `b`.
Then `fpp-locate-uses -i a.fpp,b.fpp c.fpp` generates the output `locate a at 
"a.fpp`

With `fpp-locate-uses`, you can automatically derive the equivalent of the `import`
declarations that you have to enter by hand when writing F Prime XML.
For example, suppose you have specified a port _P_ that uses a type _T_.
To specify _P_ in F Prime XML, you would write an `import` statement that
imports _T_ into _P_. In FPP you don't do this. Instead, you can do the following:

. Run `fpp-locate-defs` to generate location specifiers for all the type 
definitions.
You can do this as needed, or you can do it once and check it in as part of
the module that defines the types.

. Run `fpp-locate-uses` on _P_, using the `-i` option to pass in the result of 
step 1.

The result should be a location specifier that gives the location of _T_.
If you wish, you can check the result in as part of the definition of _P_.
This is similar to an explicit import statement, if that is desired, e.g.,
to make the dependencies explicit in the code.
Or you can just use the procedure given above generate the "import statement"
whenever desired, and see the dependencies that way.

As with `fpp-locate-defs`, you can use `-d` to specify a base directory
for the location specifiers, if you wish.

=== Computing Dependencies

TODO

Discuss `fpp-depend`.

Discuss relation between `fpp-depend` and `fpp-locate-uses`.

=== Include Specifiers

TODO
