== Specifying Models

The previous sections have explained various syntactic elements
of FPP models.
This section takes a broader view:
it explains how to assemble the elements into a model.

In the discussion below

* We focus on constants and types, because those 
elements of FPP are currently implemented.
In future versions of this User's Guide, we will extend the discussion to cover
ports, components, and topologies.

* We discuss several tools for specifying and analyzing dependencies between
model files.
Here we focus on how to use the tools, and we summarize their most important
features.
We do not attempt to cover every feature of every tool.
For more comprehensive coverage, see
https://github.jpl.nasa.gov/bocchino/fpp/wiki/Tools[the FPP wiki].

=== Dividing Models into Files

Unlike F Prime XML, FPP does not require any particular division of model 
elements into files.
For example, there is no requirement that each
type definition reside in its own file.
Nor is there any requirement that the names of files correspond
to the names of the definitions in the files.

Of course you should try to adhere to good style when decomposing a large model 
into many files.
For example:

* Group related model elements into files, and name the files
according to the purpose of the grouping.

* Choose meaningful module names, and group all files in a single module
in single directory (including its subdirectories).
Examples from the F Prime distribution include the `Fw` and `Svc`
namespaces, which correspond to modules `Fw` and `Svc` in an FPP model.

* Group files into modules and directories logically according to their function.
For example:

** You can group files according to their role in the FPP model.
For example, group types separately from ports.

** You can group files according to their role in the FSW.
For example, group framework files separately from application files.

There is still the usual requirement that a syntactic unit must begin and end 
in the same file.
For example:

* Each type definition is a syntactic unit, so each type definition must begin 
and end in the same file.

* A module definition may span several syntactic units of the form 
`module { ...  }`,
so a module definition may span multiple files (with each unit of the form
`module { ... }` residing in a single file).

These rules are similar to the way that {cpp} requires a class definition
`class C { ... }` or a namespace block `namespace N { ... }` to reside in a 
single file, but it allows the definition of a single namespace `N` to span 
multiple blocks
`namespace N { ... }` that can be in different files.

=== Include Specifiers

As part of an FPP model, you can write one or more *include specifiers*.
An include specifier is an instruction to include FPP source elements
from one file into another file.

The main purpose of include specifiers is to split up large syntactic units 
into several files.
For example, a component definition could include a telemetry dictionary
from a separate file.
In the current version of FPP, only constant and type definitions are 
available.
Because these definitions are short, include specifiers are less
useful for writing them.
However, we describe include specifiers here for completeness, anticipating
that we will need them in later versions of FPP.

To write an include specifier, you write the keyword `include`
followed by string denoting a file path.
The path is relative to the file in which the include specifier appears.

For example, suppose that the file `a.fpp` contains the definition

[source,fpp]
----
constant a = 0
----

In a file `b.fpp` in the same directory, you could write this:

[source,fpp]
--------
include "a.fpp"
constant b = a
--------

After resolving the include specifier, the model is equivalent
to the following:

[source,fpp]
----
constant a = 0
constant b = a
----

As mentioned above, the path is relative to the directory
of the file containing the include specifier.
So if `a.fpp` is located in a subdirectory `A`, you could write this:

[source,fpp]
--------
include "A/a.fpp"
constant b = a
--------

And if `a.fpp` is located in the parent directory, you could write this:

[source,fpp]
--------
include "../a.fpp"
constant b = a
--------

You can write an include specifier inside a module.
In this case, any definitions in the included file are treated as occurring 
inside the module.
For example, if `a.fpp` contains the definition `constant a = 0`,
then this source text

[source,fpp]
--------
module M { include "a.fpp" }
--------

defines the constant `M.a`.

As an exercise, try this:

----
% echo "constant a = 0" > a.fpp
% fpp-check
module M { include "a.fpp" }
constant b = M.a
^D
%
----

The check should pass.

In any case, an included file must contain complete syntactic
units that could appear at the top level or at the module level.
For example, an included file may contain one or more constant
definitions or type definitions.
It may not contain a bare identifier `a`, as this is not a valid top-level
or module-level syntactic unit.
Nor is it valid to write an include specifier in a place where an identifier 
like `a`
is expected.

For example, here is the result of a failed attempt to include
an identifier into a constant definition:

----
% echo a > a.fpp
% fpp-check
module M { constant include "a.fpp" = 0 }
constant b = M.a
^D
fpp-check
stdin: 1.21
module M { constant include "a.fpp" = 0 }
                    ^
error: identifier expected
%
----

=== Dependencies

Whenever a model spans two or more files, one file _f_ may use symbols
whose definitions appear in other files.
In order to analyze _f_, the tools must extract
the definitions from these other files, called the *dependencies* of _f_.

For example, suppose the file `a.fpp` contains the following definition:

[source,fpp]
----
constant a = 0
----

And suppose the file `b.fpp` contains the following definition:


[source,fpp]
--------
constant b = a
--------

If you present both files to `fpp-check`, like this:

----
% fpp-check a.fpp b.fpp
----

the check will pass.
However, if you present just `b.fpp`, like this:

----
% fpp-check b.fpp
----

you will get an error stating that the symbol `a` is undefined. (Try it and 
see.)
The error occurs because the definition of `a` is located in `a.fpp`,
which was not included in the analysis.

For simple models, we can manage the dependencies by hand, as we 
did for the example above.
However, for even moderately complex models, this kind of hand management 
becomes difficult.
Therefore FPP has a set of tools and features for automatic dependency
management.

In summary, dependency management in FPP works as follows:

. You run a tool called `fpp-locate-defs` to generate *location specifiers*
for all the symbols available for use in _f_.

. You run a tool called `fpp-depend`, passing it _f_ and the location 
specifiers generated in step 1.
It emits a list of files containing symbols used in _f_ (i.e., the 
dependencies of _f_).

These steps may occur in separate phases of development.
For example:

* You may run step 1 to locate and export all the type definitions
on which your model depends.

* You may run step 2 to develop ports that depend on the types.
This step would typically be run automatically as part of the build, e.g.,
the F Prime CMake build.

Below we explain these steps in more detail.

=== Location Specifiers

A location specifier is a unit of syntax in an FPP model.
Here we explain the syntax, so you know what it means.
However, you should ordinarily not write location specifiers
by hand.
Instead, you should let the tools generate them, as described
in the section on <<Specifying-Models_Locating-Definitions,locating 
definitions>>.

==== Syntax

A location specifier consists of the keyword `locate`, a kind of symbol,
the name of a symbol, and a string representing a file path.
For example, to locate the definition of constant `a` at `a.fpp`,
we would write

[source,fpp]
----
# Locating a constant definition
locate constant a at "a.fpp"
----

For the current version of FPP, the kind of symbol can be `constant` or `type`.
To locate a type `T` in a file `T.fpp`, we would write the following:

[source,fpp]
----
# Locating a type definition
locate type T at "T.fpp"
----

To locate an enum, we locate the type; the location of the enumerated
constants are then implied:

[source,fpp]
----
# Locating an enum definition,
# including the enumerated constant definitions
locate type E at "E.fpp"
----

==== Path Names

As with
<<Specifying-Models_Include-Specifiers,include specifiers>>,
the path name in a location specifier _L_ is relative to the
location of the file where _L_ appears.
For example, suppose the file `b.fpp` appears in the file system in some 
directory _D_.
Suppose also that _D_ has a subdirectory `Constants`, `Constants` contains a 
file `a.fpp`,
and `a.fpp` defines the constant `a`.
Then in `b.fpp` we could write this:

[source,fpp]
----
locate constant a at "Constants/a.fpp"
----

If, instead of residing in a subdirectory, `a.fpp` were located one directory above
`b.fpp` in the file system, we could write this:

[source,fpp]
----
locate constant a at "../a.fpp"
----

==== Symbol Names

The symbol name appearing after the keyword `locate`
may be a qualified name.
For example, suppose the file `M.fpp` contains the following:

[source,fpp]
----
module M { constant a = 0 }
----

Then in file `b.fpp` we could write this:

[source.fpp]
----
locate constant M.a at "M.fpp"
----

Optionally, we may enclose the locate specifier in the module `M`, like
this:

[source,fpp]
----
module M { locate constant a at "M.fpp" }
----

A locate specifier written inside a module this way has its symbol name
implicitly qualified with the module name.
For example, the name `a` appearing in the example above is automatically
resolved to `M.a`.

Note that this rule is less flexible than for other uses of definitions.
For example, when using the constant `M.a` in an expression inside module `M`
you may spell the constant either `a` or `M.a`;
but when referring to the same constant `M.a` in a locate specifier in module 
`M`, you must write `a` and not `M.a`.
If you wrote `M.a`, it would be incorrectly resolved to `M.M.a`.
The purpose of this restriction is to facilitate dependency analysis,
which occurs before the analyzer has complete information about
definitions and their uses.

==== Included Files

When a file that defines symbols is included in another file, the location of
each definition is the file where the definition occurs,
not the file where it is included.
For example, suppose that file `a.fpp` contains the definition `constant a = 
0`,
and suppose that file `b.fpp` contains the include specifier `include "a.fpp"`.
When analyzing `b.fpp`, the location of the definition of the constant `a`
is `a.fpp`, not `b.fpp`.

=== Locating Definitions

Given a collection of FPP source files _F_, you can generate location specifiers 
for all the symbols defined in _F_.
The tool for doing this analysis is called `fpp-locate-defs`.
As example, you can run `fpp-locate-defs` to report the locations of all
the definitions in a subdirectory called `Constants` that contains constant
definitions for your model.
When analyzing files that depend on the constants, you can use the location
specifiers to discover the dependencies.

To locate definitions, do the following:

. Collect all the FPP source files containing the definitions you want to 
locate.
For example, run `find Constants -name '*.fpp'`.

. Run `fpp-locate-defs` with the result of step 1 as the command-line 
arguments.
The result will be a list of location specifiers.

For example, suppose the file `Constants/a.fpp` defines the constant `a`.
Running

----
% fpp-locate-defs `find Constants -name '*.fpp'`
----

generates the location specifier

[source,fpp]
----
locate constant a at "Constants/a.fpp"
----

By default, the location path is relative to the current directory.
To specify a different base directory, use the option `-d`.
For example, running

----
% fpp-locate-defs -d Constants `find Constants -name '*.fpp'`
----

generates the location specifier

[source,fpp]
----
locate constant a at "a.fpp"
----

=== Computing Dependencies

TODO

Discuss `fpp-depend`.

TODO: Discuss how fpp-depend handles included files.

* By default, they are excluded from the dependency list.
This is what you want for determining which files to present to the tools.

* When you run fpp-depend with the switch `-i`, included files
appear in the dependency list.
This is what you want for computing build dependencies.

=== Locating Uses

Given a collection of files _F_ and their dependencies _D_, you can generate
the locations of the symbols defined in _D_ and used in _F_.
This is not necessary for doing analysis and translation -- the dependency 
analysis described in the previous section is sufficient.
However, by showing the dependencies between FPP files at the granularity of 
individual symbols, it provides an additional level of detail that may be 
helpful in some cases.

The tool for doing this analysis is called `fpp-locate-uses`.
As an example, you can run `fpp-locate-uses` to report the locations of all the 
type definitions used in a port definition.

To locate uses, run `fpp-locate-uses -i` _D_ _F_, where _D_ is a comma-separated
list and _F_ is a space-separated list.
The `-i` option stands for _import_: it says that the files _D_ are to be read 
for their
symbols, but not to be included in the results of the analysis.

For example, suppose `a.fpp` defines constant `a`, `b.fpp` defines constant 
`b`,
and `c.fpp` uses `a` but not `b`.
Then `fpp-locate-uses -i a.fpp,b.fpp c.fpp` generates the output `locate a at 
"a.fpp"`

With `fpp-locate-uses`, you can automatically derive the equivalent of the `import`
declarations that you have to enter by hand when writing F Prime XML.
For example, suppose you have specified a port _P_ that uses a type _T_.
To specify _P_ in F Prime XML, you would write an `import` statement that
imports _T_ into _P_. In FPP you don't do this. Instead, you can do the following:

. Run `fpp-locate-defs` to generate location specifiers _L_ for all the type 
definitions.
You can do this as needed, or you can do it once and check it in as part of
the module that defines the types.

. Run `fpp-depend` on _L_ and _P_ to generate the dependencies _D_ of _P_.

. Run `fpp-locate-uses -i` _D_ _P_.

The result should be a location specifier that gives the location of _T_.
If you wish, you can check the result in as part of the definition of _P_.
This is similar to an explicit import statement, if that is desired, e.g.,
to make the dependencies explicit in the code.
Or you can just use the procedure given above generate the "import statement"
whenever desired, and see the dependencies that way.

As with `fpp-locate-defs`, you can use `-d` to specify a base directory
for the location specifiers, if you wish.
