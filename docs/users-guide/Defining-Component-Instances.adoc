== Defining Component Instances

As discussed in the previous section, in F Prime you
define components and instantiate them.
Then you construct a *topology*, which is a graph
that specifies the connections between the components.
This section explains how to define component instances.
In the next section, we will explain how to
construct topologies.

=== Component Instance Definitions

To instantiate a component, you write a *component instance definition*.
The form of a component instance definition depends on the kind
of the component you are instantiating: passive, queued, or active.

==== Passive Components

To instantiate a passive component, you write the following:

* The keyword `instance`.

* The <<Defining-Constants_Names,name>> of the instance.

* A colon `:`.

* The name of a <<Defining-Components_Component-Definitions,component definition>>.

* The keywords `base` `id`.

* An <<Defining-Constants_Expressions,expression>> denoting
the *base identifier* associated with the component instance.

The base identifier must resolve to a number.
The FPP translator adds this number to each of the component-relative
<<Defining-Components_Commands_Opcodes,command opcodes>>,
<<Defining-Components_Events_Identifiers,event identifiers>>,
<<Defining-Components_Telemetry_Identifiers,telemetry channel identifiers>>,
and
<<Defining-Components_Parameters_Identifiers,parameter identifiers>>
specified in the component, as discussed in the previous section.
The base identifier for the instance plus the component-relative
opcode or identifier for the component gives the corresponding
opcode or identifier for the instance.

Here is an example:

[source,fpp]
----
module Sensors {

  @ A component for sensing engine temperature
  passive component EngineTemp {

    @ Schedule input port
    sync input port schedIn: Svc.Sched

    @ Telemetry port
    telemetry port tlmOut

    @ Time get port
    time get port timeGetOut

    @ Impulse drive temperature
    telemetry ImpulseDriveTemp: F32

    @ Warp core temperature
    telemetry WarpCoreTemp: F32

  }

}

module FSW {

  @ Temperature sensor instance
  instance tempSensor: Sensors.EngineTemp base id 0x100

}
----

Here we have defined a passive component `Sensors.EngineTemp` with three ports:
a schedule input port for driving the component periodically on a rate group,
a time get port for getting the time, and a telemetry port
for reporting telemetry.
(For more information on rate groups and the use of `Svc.Sched`
ports, see the F Prime documentation.)
We have given the component two telemetry channels:
`ImpulseDriveTemp` for reporting the temperature of the impulse drive,
and `WarpCoreTemp` for reporting the temperature of the warp core.

Next we have defined an instance `FSW.tempSensor` of component `Sensors.EngineTemp`.
Because the instance definition is in a different module from the
component definition, we must refer to the component by its
qualified name `Sensors.EngineTemp`.
If we wrote

[source,fpp]
--------
instance tempSensor: EngineTemp base id 0x100
--------

the FPP compiler would complain that the symbol `EngineTemp` is undefined
(try it and see).

We have specified that the base identifier of instance `FSW.tempSensor`
is the hexadecimal number 0x100 (256 decimal).
In the component definition, the telemetry channel `ImpulseDriveTemp`
has relative identifier 0, and the telemetry channel `WarpCoreTemp`
has relative identifier 1.
Therefore the corresponding telemetry channels for the instance
`FSW.tempSensor` have identifiers 0x100 and 0x101 (256 and 257)
respectively.

For consistency, the base identifier is required for all component instances,
even instances that have no commands, events telemetry,
or parameters.
For each component instance _I_, the range of numbers between the base
identifier and the base identifier plus the largest relative identifier
is called the *identifier range* of _I_.
All the numbers in the identifier range of _I_ are reserved for
instance _I_ (even if they are not all used).
No other component instance may have a base identifier in the
identifier range of _I_.

For example, this code is illegal:

[source,fpp]
-------
module FSW {

  @ Temperature sensor instance 1
  instance tempSensor1: Sensors.EngineTemp base id 0x100

  @ Temperature sensor instance 2
  instance tempSensor2: Sensors.EngineTemp base id 0x101

}
-------

The base identifier 0x101 for `tempSensor2` is inside the
identifier range for `tempSensor1`, which goes from
0x100 to 0x101, inclusive.

==== Queued Components

Instantiating a queued component is just like instantiating
a passive component, except that you must also specify
a queue size.
You do this by writing the keywords `queue` `size` and
the queue size after the base identifier.
Here is an example:

[source,fpp]
----
module Sensors {

  @ A port for calibration input
  port Calibration(cal: F32)

  @ A component for sensing engine temperature
  queued component EngineTemp {

    @ Schedule input port
    sync input port schedIn: Svc.Sched

    @ Calibration input
    async input port calibrationIn: Calibration

    @ Telemetry port
    telemetry port tlmOut

    @ Time get port
    time get port timeGetOut

    @ Impulse drive temperature
    telemetry ImpulseDriveTemp: F32

    @ Warp core temperature
    telemetry WarpCoreTemp: F32

  }

}

module FSW {

  @ Temperature sensor instance
  instance tempSensor: Sensors.EngineTemp base id 0x100 \
    queue size 10

}
----

In the component definition, we have revised the example from the previous 
section so that
the `EngineTemp` component is queued instead of passive,
and we have added an async input port for calibration input.
In the component instance definition, we have specified a queue size of 10.

==== Active Components

Instantiating an active component is again like instantiating a passive
component, except that you must specify a queue size (because the
component has a queue) and a thread stack size and thread priority
(because the component has a thread).
You specify the queue size in the same way as for a queued component.
You specify the stack size by writing the keywords `stack` `size`
and the stack size.
You specify the priority by writing the keyword `priority`
and a numeric priority.
Here is an example:

[source,fpp]
----
module Utils {

  @ A component for compressing data
  active component DataCompressor {

    @ Uncompressed input data
    async input port bufferSendIn: Fw.BufferSend

    @ Compressed output data
    output port bufferSendOut: Fw.BufferSend

  }

}

module FSW {

  module Default {
    @ Default queue size
    constant queueSize = 10
    @ Default stack size
    constant stackSize = 10 * 1024
  }

  @ Data compressor instance
  instance dataCompressor: Utils.DataCompressor base id 0x100 \
    queue size Default.queueSize \
    stack size Default.stackSize \
    priority 30

}
----

Here we have defined an active component `Utils.DataCompressor`
for compressing data.
We have defined an instance of this component called
`FSW.dataCompressor`.
Our instance has base identifier 0x100, the default
queue size, the default stack size, and priority 30.
We have used 
<<Defining-Constants,constant definitions>> for
the default queue and stack sizes.

==== Specifying Header Files

TODO

=== Init Specifiers

TODO
