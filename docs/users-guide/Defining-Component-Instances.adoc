== Defining Component Instances

As discussed in the previous section, in F Prime you
define components and instantiate them.
Then you construct a *topology*, which is a graph
that specifies the connections between the components.
This section explains how to define component instances.
In the next section, we will explain how to
construct topologies.

=== Component Instance Definitions

To instantiate a component, you write a *component instance definition*.
The form of a component instance definition depends on the kind
of the component you are instantiating: passive, queued, or active.

==== Passive Components

To instantiate a passive component, you write the following:

* The keyword `instance`.

* The <<Defining-Constants_Names,name>> of the instance.

* A colon `:`.

* The name of a <<Defining-Components_Component-Definitions,component definition>>.

* The keywords `base` `id`.

* An <<Defining-Constants_Expressions,expression>> denoting
the *base identifier* associated with the component instance.

The base identifier must resolve to a number.
The FPP translator adds this number to each of the component-relative
<<Defining-Components_Commands_Opcodes,command opcodes>>,
<<Defining-Components_Events_Identifiers,event identifiers>>,
<<Defining-Components_Telemetry_Identifiers,telemetry channel identifiers>>,
and
<<Defining-Components_Parameters_Identifiers,parameter identifiers>>
specified in the component, as discussed in the previous section.
The base identifier for the instance plus the component-relative
opcode or identifier for the component gives the corresponding
opcode or identifier for the instance.

Here is an example:

[source,fpp]
----
module Sensors {

  @ A component for sensing engine temperature
  passive component EngineTemp {

    @ Schedule input port
    sync input port schedIn: Svc.Sched

    @ Telemetry port
    telemetry port tlmOut

    @ Time get port
    time get port timeGetOut

    @ Impulse drive temperature
    telemetry ImpulseDriveTemp: F32

    @ Warp core temperature
    telemetry WarpCoreTemp: F32

  }

}

module FSW {

  @ Temperature sensor instance
  instance engineTemp: Sensors.EngineTemp base id 0x100

}
----

We have defined a passive component `Sensors.EngineTemp` with three ports:
a schedule input port for driving the component periodically on a rate group,
a time get port for getting the time, and a telemetry port
for reporting telemetry.
(For more information on rate groups and the use of `Svc.Sched`
ports, see the F Prime documentation.)
We have given the component two telemetry channels:
`ImpulseDriveTemp` for reporting the temperature of the impulse drive,
and `WarpCoreTemp` for reporting the temperature of the warp core.

Next we have defined an instance `FSW.engineTemp` of component `Sensors.EngineTemp`.
Because the instance definition is in a different module from the
component definition, we must refer to the component by its
qualified name `Sensors.EngineTemp`.
If we wrote

[source,fpp]
--------
instance engineTemp: EngineTemp base id 0x100
--------

the FPP compiler would complain that the symbol `EngineTemp` is undefined
(try it and see).

We have specified that the base identifier of instance `FSW.engineTemp`
is the hexadecimal number 0x100 (256 decimal).
In the component definition, the telemetry channel `ImpulseDriveTemp`
has relative identifier 0, and the telemetry channel `WarpCoreTemp`
has relative identifier 1.
Therefore the corresponding telemetry channels for the instance
`FSW.engineTemp` have identifiers 0x100 and 0x101 (256 and 257)
respectively.

For consistency, the base identifier is required for all component instances,
even instances that have no commands, events telemetry,
or parameters.
For each component instance _I_, the range of numbers between the base
identifier and the base identifier plus the largest relative identifier
is called the *identifier range* of _I_.
All the numbers in the identifier range of _I_ are reserved for
instance _I_ (even if they are not all used).
No other component instance may have a base identifier in the
identifier range of _I_.

For example, this code is illegal:

[source,fpp]
-------
module FSW {

  @ Temperature sensor for left engine
  instance leftEngineTemp: Sensors.EngineTemp base id 0x100

  @ Temperature sensor for right engine
  instance rightEngineTemp: Sensors.EngineTemp base id 0x101

}
-------

The base identifier 0x101 for `rightEngineTemp` is inside the
identifier range for `leftEngineTemp`, which goes from
0x100 to 0x101, inclusive.

==== Queued Components

Instantiating a queued component is just like instantiating
a passive component, except that you must also specify
a queue size for the instance.
You do this by writing the keywords `queue` `size` and
the queue size after the base identifier.
Here is an example:

[source,fpp]
----
module Sensors {

  @ A port for calibration input
  port Calibration(cal: F32)

  @ A component for sensing engine temperature
  queued component EngineTemp {

    @ Schedule input port
    sync input port schedIn: Svc.Sched

    @ Calibration input
    async input port calibrationIn: Calibration

    @ Telemetry port
    telemetry port tlmOut

    @ Time get port
    time get port timeGetOut

    @ Impulse drive temperature
    telemetry ImpulseDriveTemp: F32

    @ Warp core temperature
    telemetry WarpCoreTemp: F32

  }

}

module FSW {

  @ Temperature sensor instance
  instance engineTemp: Sensors.EngineTemp base id 0x100 \
    queue size 10

}
----

In the component definition, we have revised the example from the previous 
section so that
the `EngineTemp` component is queued instead of passive,
and we have added an async input port for calibration input.
In the component instance definition, we have specified a queue size of 10.

==== Active Components

Instantiating an active component is again like instantiating a passive
component, except that you must specify a queue size (because the
component has a queue) and a thread stack size and thread priority
(because the component has a thread).
You specify the queue size in the same way as for a queued component.
You specify the stack size by writing the keywords `stack` `size`
and the stack size.
You specify the priority by writing the keyword `priority`
and a numeric priority.
Here is an example:

[source,fpp]
----
module Utils {

  @ A component for compressing data
  active component DataCompressor {

    @ Uncompressed input data
    async input port bufferSendIn: Fw.BufferSend

    @ Compressed output data
    output port bufferSendOut: Fw.BufferSend

  }

}

module FSW {

  module Default {
    @ Default queue size
    constant queueSize = 10
    @ Default stack size
    constant stackSize = 10 * 1024
  }

  @ Data compressor instance
  instance dataCompressor: Utils.DataCompressor base id 0x100 \
    queue size Default.queueSize \
    stack size Default.stackSize \
    priority 30

}
----

We have defined an active component `Utils.DataCompressor`
for compressing data.
We have defined an instance of this component called
`FSW.dataCompressor`.
Our instance has base identifier 0x100, the default
queue size, the default stack size, and priority 30.
We have used 
<<Defining-Constants,constant definitions>> for
the default queue and stack sizes.

==== Specifying Header Files

When you define a component instance _I_, the FPP translator needs
to locate the header file for the {cpp}
implementation associated with _I_.
This location can occur automatically in many cases.
In other cases, you have to specify the location manually.

*Automatic location:*
The FPP translator can automatically locate the header file if it
conforms to the following rules:

. The header file is named `Name.fpp`, where `Name`
is the name of the component in the FPP model, without
any module qualifiers.

. The header
file is located in the same directory as the FPP
source file that defines the component.

For example, the F Prime repository contains a reference FSW implementation
with instances defined in the file `Ref/Top/init.fpp`.
One of the instances is `SG1`.
Its definition reads as follows:

[source,fpp]
--------
instance SG1: Ref.SignalGen base id 0x2100 \
  queue size Default.queueSize
--------

The FPP component `Ref.SignalGen` is
defined in the directory `Ref/SignalGen/SignalGen.fpp`,
and the implementation header file is
`Ref/SignalGen/SignalGen.hpp`.
In this case, the header file follows rules (1) and (2)
stated above, so the FPP translator can automatically locate
the file.

*Manual specification:*
If the implementation header file does not follow
rules (1) and (2) stated above, then you must specify
the name and location of the header file by hand.
You do that by writing the keyword `at` followed by the
header file path enclosed in quotation marks.
The header file path is relative to the directory
containing the source file that defines the component
instance.

For example, the F Prime repository has a directory
`Svc/Time` that contains an FPP model for a component
`Svc.Time`.
Because the {cpp} implementation for this component
is platform-specific, the directory `Svc/Time` doesn't
contain any implementation.
Instead, when instantiating the component, you have to
provide the header file to an implementation located
in a different directory.

The F Prime repository also provides a Linux-specific implementation
of the `Time` component in the directory `Svc/LinuxTime`.
The file `Ref/Top/init.fpp` contains an instance definition
`linuxTime` that reads as follows:

[source,fpp]
----
instance linuxTime: Svc.Time base id 0x4500 \
  at "../../Svc/LinuxTime/LinuxTimeImpl.hpp"
----

This definition says to use implementation header file
`Svc/LinuxTime/LinuxTimeImpl.hpp`.

=== Init Specifiers

TODO
