== Defining Components

In F Prime, the *component* is the basic unit of FSW function.
An F Prime component is similar to a class in an object-oriented language.
An F Prime FSW application is divided into several
*component instances*, each of which instantiates a component.
The component instances communicate by sending and receiving
invocations on their
<<Defining-Ports, ports>>.

In F Prime, there are three kinds of components:
active, queued, and passive.
An active component has a thread of control
and a message queue.
A queued component has a message queue, but no thread
of control; control runs on another thread, such as
a rate group thread.
A passive component has no thread of control and no
message queue; it is like a non-threaded function library.

=== Component Definitions

An FPP *component definition* defines an F Prime component.
To write a component definition, you write the following:

* The component kind: one of `active`, `passive`,
or `queued`.
* The keyword `component`.
* The <<Defining-Constants_Names,name>> of the component.
* A sequence of *component members* enclosed in curly braces
`{` ... `}`.

As an example, here is a passive component `C` with no members:

[source,fpp]
----
@ An empty passive component
passive component C {

}
----

A component definition and each of its members is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
For example, you can annotate the component as shown above.
The following sections describe the available component members.

=== Port Instances

A *port instance* is a component member that specifies an instance of an FPP
<<Defining-Ports, port>> used by the component.
The port definition provides information common to all uses of the port, such as
the kind of data carried on the port.
The port instance provides use-specific information, such
as the name of the instance and the the direction of invocation
(input or output).

==== Basic Port Instances

The simplest port instance specifies a kind, a name, and a type.
The kind is one of the following:

* `async` `input`: Input to this component that arrives on a message queue, to
be dispatched on this component's thread (if this component is active)
or on the thread of another port invocation (if this component is queued).

* `sync` `input`: Input that invokes a handler defined in this component,
and run on the thread of the caller.

* `guarded` `input`: Similar to sync input, but the handler is 
guarded by a mutual exclusion lock.

* `output`: Output transmitted by this component.

The name is the name of the port instance.
The type refers to a <<Defining-Ports,port definition>>.

As an example, here is a passive component `F32Adder` that
adds two `F32` values and produces an `F32` value.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Input 1
  sync input port f32ValueIn1: F32Value

  @ Input 2
  sync input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

There are two sync input port instances and one output port
instance.
The kind appears first, followed by the keyword `port`, the port instance
name, a colon, and the type.
Each port instance is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>,
so you can annotate the instances as shown.

As another example, here is an active version of `F32Adder`
with `async` input ports:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
active component ActiveF32Adder {

  @ Input 1
  async input port f32ValueIn1: F32Value

  @ Input 2
  async input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

In each case, the adding is done in the target language.
For example, in the {cpp} implementation, you would generate a
base class with a virtual handler function, and then override that virtual
function in a derived class that you write.
For further details about implementing F Prime components, see the
F Prime User's Guide.

*Note on terminology:* As explained above, there is a technical
distinction between a _port_ (defined outside any component, and providing
the type of a port instance)
and a _port instance_ (defined inside a component and instantiating
a port type).
However, it is sometimes useful to refer to a port instance with
the shorter term "port" when there is no danger of confusion.
We will do that in this manual.
For example, we will say that the `F32Adder` component has three
ports: two async input ports of type `F32Value` and one output port
of type `F32Value`.

==== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Try presenting this code to `fpp-check` and observe what happens.

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
--------
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
--------

==== Arrays of Port Instances

When you specify a port instance as part of an FPP component, you
are actually specifying an _array_ of port instances.
Each instance has a _port number_, where the port numbers start at zero
and go up by one at each successive element.
(Another way to say this is that the port numbers are the array indices,
and the indices start at zero.)

If you don't specify a size for the array, as in the examples in
the previous sections, then the array has size one, and there is a single port 
instance with port number zero.
Thus a port instance specifier with no array size acts like a singleton element.
Alternatively, you can specify an explicit array size.
You do that by writing an <<Defining-Constants_Expressions,expression>>
enclosed in square brackets `[` ... `]` denoting the size (number of elements) 
of the array.
The size expression must evaluate to a numeric value.
As with <<Defining-Types_Array-Type-Definitions_Writing-an-Array-Type-Definition,
array type definitions>>,
the size goes before the element type.
As an example, here is another version of the `F32Adder` component, this time
using a single array of two input ports instead of two named ports.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Inputs 0 and 1
  sync input port f32ValueIn: [2] F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

==== Specifying Priority

For `async` `input` ports, you may specify a priority.
The priority specification is not allowed for other kinds of ports.
To specify a priority, you write the keyword `priority` and an
expression that evaluates to a numeric value after the port type.
As an example, here is a modified version of the `ActiveF32Adder`
with specified priorities:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10
  async input port f32ValueIn1: F32Value priority 10

  @ Input 2 at priority 20
  async input port f32ValueIn2: F32Value priority 20

  @ Output
  output port f32ValueOut: F32Value

}
----

If an `async` `input` port has no specified priority, then the
translator uses a default priority.
The precise meaning of the default priority and of the numeric priorities is
implementation-specific.
In general the priorities regulate the order in which elements are dispatched
from the message queue.

==== Specifying Queue Full Behavior

By default, if an invocation of an `async` `input` port causes
a message queue to overflow, then a *FSW assertion* fails.
A FSW assertion is a condition that must be true in order
for FSW execution to proceed safely.
The behavior of a FSW assertion failure is configurable in the {cpp}
implementation of the F Prime framework; typically it causes a FSW
abort and system reset.

Optionally, you can specify the behavior when a message
received on an `async` `input` port causes a queue overflow.
There are three possible behaviors:

. `assert`: Fail a FSW assertion (the default behavior).
. `block`: Block the sender until the queue is available.
. `drop`: Drop the incoming message and proceed.

To specify queue full behavior, you write one of the keywords `assert`,
`block`, or `drop` after the port type and after the priority
(if any).
As an example, here is the `ActiveF32Adder` updated with explicit
queue full behavior.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10: Block on queue full
  async input port f32ValueIn1: F32Value priority 10 block

  @ Input 2: Drop on queue full
  async input port f32ValueIn2: F32Value drop

  @ Output
  output port f32ValueOut: F32Value

}
----

As for priority specifiers, queue full specifiers are allowed only
for `async` `input` ports.

==== Serial Port Instances

When writing a port instance, instead of specifying a named port type,
you may write the keyword `serial`.
Doing this specifies a *serial port instance*.
A serial port instance does not specify the type of data that it carries.
It may be connected to a port of any type.
Serial data passes through the port; the data may be converted to or from a 
specific type at the other end of the connection.

As an example, here is a passive component for taking a stream
of serial data and splitting it (i.e., repeating it by copy)
onto several streams:

[source,fpp]
----
@ Split factor
constant splitFactor = 10

@ Component for splitting a serial data stream
passive component SerialSplitter {

  @ Input
  sync input port serialIn: serial

  @ Output
  output port serialOut: [splitFactor] serial

}
----

By using serial ports, you can send several unrelated types
of data over the same port connection.
This technique is useful when communicating across
a network: on each side of the network connection, a single component
can act as a hub that routs all data to and from components
on that side.
This flexibility comes at the cost that you lose the type
compile-time type checking provided by port connections with named types.
For more information about serial ports and their use, see
the F Prime User's Guide.

=== Special Port Instances

A *special port instance* is a port instance that has a special
behavior in F Prime.
As discussed <<Defining-Components_Port-Instances,above>>,
when writing a general port instance,
you specify a port kind, a port type, and possibly other
information such as array size and priority.
Writing a special port instance is a bit different.
In this case you specify a predefined behavior
provided by the F Prime framework.
The special port behaviors fall into five groups:
commands, events, telemetry, parameters, and time.

==== Commands

A *command* is an instruction to the spacecraft to perform an action.
The special command behaviors, and their keywords, are as follows:

* `command` `recv`: A port for receiving commands.
* `command` `reg`: A port for sending command registration requests.
* `command` `resp`: A port for sending command responses.

Collectively, these ports are known as *command ports*.
To specify a command port, you write one of the keyword pairs
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `CommandPorts` with each
of the command ports:

[source,fpp]
----
@ A component for illustrating command ports
passive component CommandPorts {

  @ A port for receiving commands
  command recv port cmdIn

  @ A port for sending command registration requests
  command reg port cmdRegOut

  @ A port for sending command responses
  command resp port cmdResponseOut

}
----

Any component may have at most one of each kind of command
port.
If a component receives commands (more on this below),
then all three ports are required.
The port names shown in the example above are standard but not
required; you can use any names you wish.

During translation, each command port is converted into 
a typed port instance with a predefined port type, as follows:

* `cmd` `recv` uses the port `Fw.Cmd`
* `cmd` `reg` uses the port `Fw.CmdReg`
* `cmd` `resp` uses the port `Fw.CmdResponse`

The F Prime framework provides definitions for these ports
in the directory `Fw/Cmd`.
For checking simple examples, you can use the following 
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port Cmd
  port CmdReg
  port CmdResponse
}
--------

For example, to check the `CommandPorts` component, you can
add these lines before the component definition.
If you don't do this, or something similar, then the component
definition won't pass through `fpp-check` because of the missing ports.
(Try it and see.)

Note that the port definitions shown above are for conveniently checking
simple examples only.
They are not correct for the F Prime framework and will not work
properly with F Prime {cpp} code generation.

For further information about command registration, receipt, and
response, and implementing command handlers, see the
F Prime User's Guide.

==== Events

An *event* is a report that something happened, for example,
that a file was successfully uplinked.
The special event behaviors, and their keywords, are as follows:

* `event`: A port for emitting events as serialized bytes.
* `text` `event`: A port for emitting events as human-readable
text (usually used for testing and debugging on the ground).

Collectively, these ports are known as *event ports*.
To specify an event port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `EventPorts` with each
of the event ports:

[source,fpp]
----
@ A component for illustrating event ports
passive component EventPorts {

  @ A port for emitting events
  event port eventOut

  @ A port for emitting text events
  text event port textEventOut

}
----

Any component may have at most one of each kind of event
port.
If a component emits events (more on this below),
then (1) an event port is required; and (2) a text event
port is required if text logging is enabled in the F Prime
framework.

During translation, each event port is converted into 
a typed port instance with a predefined port type, as follows:

* `event` `recv` uses the port `Fw.Log`
* `text` `event` uses the port `Fw.LogText`

The name `Log` refers to an event log.
The F Prime framework provides definitions for these ports
in the directory `Fw/Log`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port Log
  port LogText
}
--------

For further information about events in F Prime, see the
F Prime User's Guide.

==== Telemetry

*Telemetry* is data regarding the state of the system.
A *telemetry port* lets a component emit telemetry.
To specify a telemetry port, you write the keyword `telemetry`,
the keyword `port`, and the port name.

As an example, here is a passive component `TelemetryPorts` with 
a telemetry port:

[source,fpp]
----
@ A component for illustrating telemetry ports
passive component TelemetryPorts {

  @ A port for emitting telemetry
  telemetry port tlmOut

}
----

Any component may have at most one telemetry port.
If a component emits telemetry (more on this below),
then a telemetry port is required.

During translation, each telemetry port is converted into 
a typed port instance with the predefined port type
`Fw.Tlm`.
The F Prime framework provides a definition for this port
in the directory `Fw/Tlm`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
--------
module Fw {
  port Tlm
}
--------

For further information about telemetry in F Prime, see the
F Prime User's Guide.

==== Parameters

A *parameter* is a configurable constant that may be updated
from the ground.
The current parameter values are stored in an F Prime component
called the *parameter database*.

The special parameter behaviors, and their keywords, are as follows:

* `param` `get`: A port for getting the current value of a parameter
from the parameter database.
* `param` `set`: A port for setting the current value of a parameter
in the parameter database.

Collectively, these ports are known as *parameter ports*.
To specify a parameter port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `ParamPorts` with each
of the parameter ports:

[source,fpp]
----
@ A component for illustrating parameter ports
passive component ParamPorts {

  @ A port for getting parameter values
  param get port prmGetOut

  @ A port for setting parameter values
  param set port prmSetOut

}
----

Any component may have at most one of each kind of parameter
port.
If a component has parameters (more on this below),
then both parameter ports are required.

During translation, each parameter port is converted into 
a typed port instance with a predefined port type, as follows:

* `param` `get` uses the port `Fw.PrmGet`
* `param` `set` uses the port `Fw.PrmSet`

The F Prime framework provides definitions for these ports
in the directory `Fw/Prm`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port PrmGet
  port PrmSet
}
--------

For further information about parameters in F Prime, see the
F Prime User's Guide.


==== Time

A *time get port* lets a component get the system time from a
time component.
To specify a time get port, you write the keywords `time` `get`,
the keyword `port`, and the port name.

As an example, here is a passive component `TimeGetPorts` with 
a time get port:

[source,fpp]
----
@ A component for illustrating time get ports
passive component TimeGetPorts {

  @ A port for getting the time
  time get port timeGetOut

}
----

Any component may have at most one time get port.
If a component emits events or telemetry (more on this below),
then a time get port is required, so that the events
and telemetry points can be time stamped.

During translation, each time get port is converted into 
a typed port instance with the predefined port type
`Fw.Time`.
The F Prime framework provides a definition for this port
in the directory `Fw/Time`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
--------
module Fw {
  port Time
}
--------

For further information about time in F Prime, see the
F Prime User's Guide.

=== Internal Ports

An *internal port* is a port that a component can use to send a
message to itself.
In the ordinary case, when a component sends a message, it invokes an
output port that is connected to an async input port.
When the output port and input port reside in the same component,
it is simpler to use an internal port.

As an example, suppose we have a component 
that needs to send a message to itself.
We could construct such a component in the following way:

[source,fpp]
----
@ A data type T
type T

@ A port for sending data of type T
port P(t: T)

@ A component that sends data to itself on an async input port
active component ExternalSelfMessage {

  @ A port for sending data of type T
  async input port pIn: P

  @ A port for receiving data of type T
  output port pOut: P

}
----

This works, but if the only user of `pIn` is 
`ExternalSelfMessage`, it is cumbersome.
We need to declare two ports and connect them.
Instead, we can use an internal port, like this:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T)

}
----

When the implementation of `ExternalSelfMessage` invokes
the port `pInternal`, a message goes on its queue.
This corresponds to the behavior of `pOut` in
`ExternalSelfMessage`.
Later, when the framework dispatches the message is dispatched, it
calls a handler function associated with the port.
This corresponds to the behavior of `pIn` in
`ExternalSelfMessage`.
So an internal port is like two ports (an output port
and an async input port) fused into one.

Internal ports are single-use, so they do not use named
port definitions.
Instead, when writing an internal port, you provide
the formal parameters directly.
Notice that when defining `ExternalSelfMessage` we
defined and used the port `P`, but when defining
`InternalSelfMessage` we did not.
The formal parameters of an internal port are the same
as for a <<Defining-Ports_Formal-Parameters,port definition>>, except
that none of the parameters may be a
<<Defining-Ports_Reference-Parameters,reference parameter>>.

When specifying an internal port, you may specify
<<Defining-Components_Port-Instances_Specifying-Priority,priority>> and
<<Defining-Components_Port-Instances_Specifying-Queue-Full-Behavior,queue full behavior>>
as for an async input port.
For example, we can add priority and queue full behavior
to `pInternal` as follows:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port,
@ with priority and queue full behavior
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T) priority 10 drop

}
----

Internal ports generate async input, so they make sense
only for `active` and `queued` components.
As an example, consider the following component
definition:

[source,fpp]
--------
type T

passive component PassiveInternalPort {

  # Internal ports don't make sense for passive components
  internal port pInternal(t: T)

}
--------

What do you think will happen if you run `fpp-check`
on this code?
Try it and see.

=== Commands

When defining an F Prime component, you may specify one or more commands.
When operating the FSW, each command is dispatched to, and handled
by, an instance of the component where it is defined.
The handling occurs in a {cpp} command handler that you write
as part of the component implementation.

For more information about F Prime command dispatch and
handling, see the F Prime User's Guide.
Here we concentrate on how to specify commands in FPP.

==== Basic Commands

The simplest command specifies a kind and a name.
The kind is one of the following:

* `async`: The command arrives on a message queue, to
be dispatched on this component's thread (if this component is active)
or on the thread of a port invocation (if this component is queued).

* `sync`: The command invokes a handler defined in this component,
and run on the thread of the caller.

* `guarded`: Similar to sync input, but the handler is
guarded by a mutual exclusion lock.

Notice that the kinds of commands are similar to the kinds of
<<Defining-Components_Port-Instances_Basic-Port-Instances,
input ports>>.
The name is the name of the command.

As an example, here is an active component called `Action`
with two commands: an async command `START` and a sync
command `STOP`.

[source,fpp]
----
@ An active component for performing an action
active component Action {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ Start the action
  async command START

  @ Stop the action
  sync command STOP

}
----

Command `START` is declared `async`.
That means that when a `START` command is dispatched
to an instance of this component, it arrives on a queue.
Later, the F Prime framework takes the message off the queue
and calls the corresponding handler on the thread
of the component.

Command `STOP` is declared `sync`.
That means that the command runs immediately on the
thread of the invoking component (for example,
a command dispatcher component).
Because the command runs immediately, its handler
should be very short.
For example, it could set a stop flag and then exit.

Notice that we defined the three
<<Defining-Components_Special-Port-Instances_Commands, command ports>>
for this component.
All three ports are required for any component that has commands.
We discuss this and other rules relating to commands in the
next section.

==== Rules for Commands

TODO

==== Specifying Formal Parameters

TODO

==== Specifying the Opcode

TODO

==== Specifying Priority and Queue Full Behavior

TODO

=== Events

TODO

=== Telemetry

TODO

=== Parameters

TODO

=== Constants and Types

TODO

=== Include Specifiers

TODO
