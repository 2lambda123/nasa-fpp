== Defining Components

In F Prime, the *component* is the basic unit of FSW function.
An F Prime component is similar to a class in an object-oriented language.
An F Prime FSW application is divided into several
*component instances*, each of which instantiates a component.
The component instances communicate by sending and receiving
invocations on their
<<Defining-Ports, ports>>.

In FPP, as in F Prime, there are three kinds of components:
active, queued, and passive.
An active component has a thread of control
and a message queue.
A queued component has a message queue, but no thread
of control; control runs on another thread, such as
a rate group thread.
A passive component has no thread of control and no
message queue; it is like a non-threaded function library.

=== Component Definitions

An FPP *component definition* defines an F Prime component.
To write a component definition, you write the following:

* The component kind: one of `active`, `passive`,
or `queued`.
* The keyword `component`.
* The <<Defining-Constants_Names,name>> of the component.
* A sequence of *component members* enclosed in curly braces
`{` ... `}`.

As an example, here is a passive component `C` with no members:

[source,fpp]
----
@ An empty passive component
passive component C {

}
----

A component definition is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>,
so you can annotate it, as shown.
The following sections describe the possible component members.

=== Port Instances

A *port instance* is a component member that specifies an instance of an FPP
<<Defining-Ports, port>> used by the component.
The port definition provides information common to all uses of the port, such as
the kind of data carried on the port.
The port instance provides use-specific information, such
as the name of the instance and the the direction of invocation
(input or output).

==== Basic Port Instances

The simplest port instance specifies a kind, a name, and a type.
The kind is one of the following:

* `async` `input`: Input to this component that arrives on a message queue, to
be dispatched on this component's thread (if this component is active)
or on the thread of another port invocation (if this component is queued).

* `sync` `input`: Input that invokes a handler defined in this component,
but run on the thread of the caller.

* `guarded` `input`: Similar to sync input, but guarded by a mutual
exclusion lock.

* `output`: Output transmitted by this component.

The name is the name of the port instance.
The type refers to a <<Defining-Ports,port definition>>.

As an example, here is a passive component `F32Adder` that
adds two `F32` values and produces an `F32` value.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Input 1
  sync input port f32ValueIn1: F32Value

  @ Input 2
  sync input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

There are two sync input port instances and one output port
instance.
The kind appears first, followed by the keyword `port`, the port instance
name, a colon, and the type.
Each port instance is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>,
so you can annotate the instances as shown.

As another example, here is an active version of `F32Adder`
with `async` input ports:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
active component ActiveF32Adder {

  @ Input 1
  async input port f32ValueIn1: F32Value

  @ Input 2
  async input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

In each case, the actual adding is done in the target language.
For example, in the {cpp} implementation, you would generate a
base class with a virtual handler function, and then override that virtual
function in a derived class that you write.
For further details about implementing F Prime components, see the
F Prime User's Guide.

*Note on terminology:* As explained above, there is a technical
distinction between a _port_ (defined outside any component, and providing
the type of a port instance)
and a _port instance_ (defined inside a component and instantiating
a port type).
However, it is sometimes useful to refer to a port instance with
the shorter term "port" when there is no danger of confusion.
We will do that in this manual.
For example, we will say that the `F32Adder` component has three
ports: two async input ports of type `F32Value` and one output port
of type `F32Value`.

==== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Try presenting this code to `fpp-check` and observe what happens.

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because passing returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
--------
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
--------

==== Arrays of Port Instances

When you specify a port instance as part of an FPP component, you
are actually specifying an _array_ of port instances.
Each instance has a _port number_, where the port numbers start at zero
and go up by one at each successive element.
(Another way to say this is that the port numbers are the array indices,
and the indices start at zero.)

If you don't specify a size for the array, as in the examples in
the previous sections, then the array has size one, and there is a single port 
instance with port number zero.
Thus a port instance specifier with no array size acts like a singleton element.
Alternatively, you can specify an explicit array size.
You do that by writing an <<Defining-Constants_Expressions,expression>>
enclosed in square brackets `[` ... `]` denoting the size (number of elements) 
of the array.
The size expression must evaluate to a numeric value.
As with <<Defining-Types_Array-Type-Definitions_Writing-an-Array-Type-Definition,
array type definitions>>,
the size goes before the element type.
As an example, here is another version of the `F32Adder` component, this time
using a single array of two input ports instead of two named ports.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Inputs 0 and 1
  sync input port f32ValueIn: [2] F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

==== Specifying Priority

For `async` `input` ports, you may specify a priority.
The priority specification is not allowed for other kinds of ports.
To specify a priority, you write the keyword `priority` and an
expression that evaluates to a numeric value after the port type.
As an example, here is a modified version of the `ActiveF32Adder`
with specified priorities:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10
  async input port f32ValueIn1: F32Value priority 10

  @ Input 2 at priority 20
  async input port f32ValueIn2: F32Value priority 20

  @ Output
  output port f32ValueOut: F32Value

}
----

If an `async` `input` port has no specified priority, then the
translator uses a default priority.
The precise meaning of the default priority and of the numeric priorities is
implementation-specific.
In general the priorities regulate the order in which elements are dispatched
from the message queue.

==== Specifying Queue Full Behavior

By default, if an invocation of an `async` `input` port causes
a message queue to overflow, then a *FSW assertion* fails.
A FSW assertion is a condition that must be true in order
for FSW execution to proceed safely.
The behavior of a FSW assertion failure is configurable in the {cpp}
implementation F Prime framework; typically it causes a FSW
abort and system reset.

Optionally, you can specify the behavior when a message
received on an `async` `input` port causes a queue overflow.
There are three possible behaviors:

. `assert`: Fail a FSW assertion (the default behavior).
. `block`: Block the sender until the queue is available.
. `drop`: Drop the incoming message and proceed.

To specify queue full behavior, you write one of the keywords `assert`,
`block`, or `drop` after the port type and after the priority
(if any).
As an example, here is the `ActiveF32Adder` updated with explicit
queue full behavior.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10: Block on queue full
  async input port f32ValueIn1: F32Value priority 10 block

  @ Input 2: Drop on queue full
  async input port f32ValueIn2: F32Value drop

  @ Output
  output port f32ValueOut: F32Value

}
----

As for priority specifiers, queue full specifiers are allowed only
for `async` `input` ports.

==== Serial Port Instances

When writing a port instance, instead of specifying a named port type,
you may write the keyword `serial`.
Doing this specifies a *serial port instance*.
A serial port instance does not specify the type of data that it carries.
It may be connected to a port of any type.
Serial data passes through the port; the data may be converted to or from a 
specific type at the other end of the connection.

As an example, here is a passive component for taking a stream
of serial data and splitting it (i.e., repeating it by copy)
onto several streams:

[source,fpp]
----
@ Split factor
constant splitFactor = 10

@ Component for splitting a serial data stream
passive component SerialSplitter {

  @ Input
  sync input port serialIn: serial

  @ Output
  output port serialOut: [splitFactor] serial

}
----

=== Special Port Instances

TODO

=== Internal Ports

TODO

=== Commands

TODO

=== Events

TODO

=== Telemetry

TODO

=== Parameters

TODO

=== Constants and Types

TODO

=== Include Specifiers

TODO
