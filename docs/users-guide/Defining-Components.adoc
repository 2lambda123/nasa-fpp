== Defining Components

In F Prime, the *component* is the basic unit of FSW function.
An F Prime component is similar to a class in an object-oriented language.
An F Prime FSW application is divided into several
*component instances*, each of which instantiates a component.
The component instances communicate by sending and receiving
invocations on their
<<Defining-Ports, ports>>.

In F Prime, there are three kinds of components:
active, queued, and passive.
An active component has a thread of control
and a message queue.
A queued component has a message queue, but no thread
of control; control runs on another thread, such as
a rate group thread.
A passive component has no thread of control and no
message queue; it is like a non-threaded function library.

=== Component Definitions

An FPP *component definition* defines an F Prime component.
To write a component definition, you write the following:

* The component kind: one of `active`, `passive`,
or `queued`.
* The keyword `component`.
* The <<Defining-Constants_Names,name>> of the component.
* A sequence of *component members* enclosed in curly braces
`{` ... `}`.

As an example, here is a passive component `C` with no members:

[source,fpp]
----
@ An empty passive component
passive component C {

}
----

A component definition and each of its members is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
For example, you can annotate the component as shown above.
The following sections describe the available component members.

=== Port Instances

A *port instance* is a component member that specifies an instance of an FPP
<<Defining-Ports, port>> used by the component.
The port definition provides information common to all uses of the port, such as
the kind of data carried on the port.
The port instance provides use-specific information, such
as the name of the instance and the the direction of invocation
(input or output).

==== Basic Port Instances

The simplest port instance specifies a kind, a name, and a type.
The kind is one of the following:

* `async` `input`: Input to this component that arrives on a message queue, to
be dispatched on this component's thread (if this component is active)
or on the thread of another port invocation (if this component is queued).

* `sync` `input`: Input that invokes a handler defined in this component,
and run on the thread of the caller.

* `guarded` `input`: Similar to sync input, but the handler is 
guarded by a mutual exclusion lock.

* `output`: Output transmitted by this component.

The name is the name of the port instance.
The type refers to a <<Defining-Ports,port definition>>.

As an example, here is a passive component `F32Adder` that
adds two `F32` values and produces an `F32` value.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Input 1
  sync input port f32ValueIn1: F32Value

  @ Input 2
  sync input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

There are two sync input port instances and one output port
instance.
The kind appears first, followed by the keyword `port`, the port instance
name, a colon, and the type.
Each port instance is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>,
so you can annotate the instances as shown.

As another example, here is an active version of `F32Adder`
with `async` input ports:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
active component ActiveF32Adder {

  @ Input 1
  async input port f32ValueIn1: F32Value

  @ Input 2
  async input port f32ValueIn2: F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

In each case, the adding is done in the target language.
For example, in the {cpp} implementation, you would generate a
base class with a virtual handler function, and then override that virtual
function in a derived class that you write.
For further details about implementing F Prime components, see the
F Prime User's Guide.

*Note on terminology:* As explained above, there is a technical
distinction between a _port_ (defined outside any component, and providing
the type of a port instance)
and a _port instance_ (defined inside a component and instantiating
a port type).
However, it is sometimes useful to refer to a port instance with
the shorter term "port" when there is no danger of confusion.
We will do that in this manual.
For example, we will say that the `F32Adder` component has three
ports: two async input ports of type `F32Value` and one output port
of type `F32Value`.

==== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Try presenting this code to `fpp-check` and observe what happens.

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
--------
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
--------

==== Arrays of Port Instances

When you specify a port instance as part of an FPP component, you
are actually specifying an _array_ of port instances.
Each instance has a _port number_, where the port numbers start at zero
and go up by one at each successive element.
(Another way to say this is that the port numbers are the array indices,
and the indices start at zero.)

If you don't specify a size for the array, as shown in
the previous sections, then the array has size one, and there is a single port 
instance with port number zero.
Thus a port instance specifier with no array size acts like a singleton 
element.
Alternatively, you can specify an explicit array size.
You do that by writing an <<Defining-Constants_Expressions,expression>>
enclosed in square brackets `[` ... `]` denoting the size (number of elements) 
of the array.
The size expression must evaluate to a numeric value.
As with 
<<Defining-Types_Array-Type-Definitions_Writing-an-Array-Type-Definition,
array type definitions>>,
the size goes before the element type.
As an example, here is another version of the `F32Adder` component, this time
using a single array of two input ports instead of two named ports.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ A passive component for adding two F32 values
passive component F32Adder {

  @ Inputs 0 and 1
  sync input port f32ValueIn: [2] F32Value

  @ Output
  output port f32ValueOut: F32Value

}
----

==== Priority

For `async` `input` ports, you may specify a priority.
The priority specification is not allowed for other kinds of ports.
To specify a priority, you write the keyword `priority` and an
expression that evaluates to a numeric value after the port type.
As an example, here is a modified version of the `ActiveF32Adder`
with specified priorities:

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10
  async input port f32ValueIn1: F32Value priority 10

  @ Input 2 at priority 20
  async input port f32ValueIn2: F32Value priority 20

  @ Output
  output port f32ValueOut: F32Value

}
----

If an `async` `input` port has no specified priority, then the
translator uses a default priority.
The precise meaning of the default priority and of the numeric priorities is
implementation-specific.
In general the priorities regulate the order in which elements are dispatched
from the message queue.

==== Queue Full Behavior

By default, if an invocation of an `async` `input` port causes
a message queue to overflow, then a *FSW assertion* fails.
A FSW assertion is a condition that must be true in order
for FSW execution to proceed safely.
The behavior of a FSW assertion failure is configurable in the {cpp}
implementation of the F Prime framework; typically it causes a FSW
abort and system reset.

Optionally, you can specify the behavior when a message
received on an `async` `input` port causes a queue overflow.
There are three possible behaviors:

. `assert`: Fail a FSW assertion (the default behavior).
. `block`: Block the sender until the queue is available.
. `drop`: Drop the incoming message and proceed.

To specify queue full behavior, you write one of the keywords `assert`,
`block`, or `drop` after the port type and after the priority
(if any).
As an example, here is the `ActiveF32Adder` updated with explicit
queue full behavior.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10: Block on queue full
  async input port f32ValueIn1: F32Value priority 10 block

  @ Input 2: Drop on queue full
  async input port f32ValueIn2: F32Value drop

  @ Output
  output port f32ValueOut: F32Value

}
----

As for priority specifiers, queue full specifiers are allowed only
for `async` `input` ports.

==== Serial Port Instances

When writing a port instance, instead of specifying a named port type,
you may write the keyword `serial`.
Doing this specifies a *serial port instance*.
A serial port instance does not specify the type of data that it carries.
It may be connected to a port of any type.
Serial data passes through the port; the data may be converted to or from a 
specific type at the other end of the connection.

As an example, here is a passive component for taking a stream
of serial data and splitting it (i.e., repeating it by copy)
onto several streams:

[source,fpp]
----
@ Split factor
constant splitFactor = 10

@ Component for splitting a serial data stream
passive component SerialSplitter {

  @ Input
  sync input port serialIn: serial

  @ Output
  output port serialOut: [splitFactor] serial

}
----

By using serial ports, you can send several unrelated types
of data over the same port connection.
This technique is useful when communicating across
a network: on each side of the network connection, a single component
can act as a hub that routs all data to and from components
on that side.
This flexibility comes at the cost that you lose the type
compile-time type checking provided by port connections with named types.
For more information about serial ports and their use, see
the F Prime User's Guide.

=== Special Port Instances

A *special port instance* is a port instance that has a special
behavior in F Prime.
As discussed <<Defining-Components_Port-Instances,above>>,
when writing a general port instance,
you specify a port kind, a port type, and possibly other
information such as array size and priority.
Writing a special port instance is a bit different.
In this case you specify a predefined behavior
provided by the F Prime framework.
The special port behaviors fall into five groups:
commands, events, telemetry, parameters, and time.

==== Command Ports

A *command* is an instruction to the spacecraft to perform an action.
The special command behaviors, and their keywords, are as follows:

* `command` `recv`: A port for receiving commands.
* `command` `reg`: A port for sending command registration requests.
* `command` `resp`: A port for sending command responses.

Collectively, these ports are known as *command ports*.
To specify a command port, you write one of the keyword pairs
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `CommandPorts` with each
of the command ports:

[source,fpp]
----
@ A component for illustrating command ports
passive component CommandPorts {

  @ A port for receiving commands
  command recv port cmdIn

  @ A port for sending command registration requests
  command reg port cmdRegOut

  @ A port for sending command responses
  command resp port cmdResponseOut

}
----

Any component may have at most one of each kind of command
port.
If a component receives commands (more on this below),
then all three ports are required.
The port names shown in the example above are standard but not
required; you can use any names you wish.

During translation, each command port is converted into 
a typed port instance with a predefined port type, as follows:

* `cmd` `recv` uses the port `Fw.Cmd`
* `cmd` `reg` uses the port `Fw.CmdReg`
* `cmd` `resp` uses the port `Fw.CmdResponse`

The F Prime framework provides definitions for these ports
in the directory `Fw/Cmd`.
For checking simple examples, you can use the following 
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port Cmd
  port CmdReg
  port CmdResponse
}
--------

For example, to check the `CommandPorts` component, you can
add these lines before the component definition.
If you don't do this, or something similar, then the component
definition won't pass through `fpp-check` because of the missing ports.
(Try it and see.)

Note that the port definitions shown above are for conveniently checking
simple examples only.
They are not correct for the F Prime framework and will not work
properly with F Prime {cpp} code generation.

For further information about command registration, receipt, and
response, and implementing command handlers, see the
F Prime User's Guide.

==== Event Ports

An *event* is a report that something happened, for example,
that a file was successfully uplinked.
The special event behaviors, and their keywords, are as follows:

* `event`: A port for emitting events as serialized bytes.
* `text` `event`: A port for emitting events as human-readable
text (usually used for testing and debugging on the ground).

Collectively, these ports are known as *event ports*.
To specify an event port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `EventPorts` with each
of the event ports:

[source,fpp]
----
@ A component for illustrating event ports
passive component EventPorts {

  @ A port for emitting events
  event port eventOut

  @ A port for emitting text events
  text event port textEventOut

}
----

Any component may have at most one of each kind of event
port.
If a component emits events (more on this below),
then both event ports are required.

During translation, each event port is converted into 
a typed port instance with a predefined port type, as follows:

* `event` `recv` uses the port `Fw.Log`
* `text` `event` uses the port `Fw.LogText`

The name `Log` refers to an event log.
The F Prime framework provides definitions for these ports
in the directory `Fw/Log`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port Log
  port LogText
}
--------

For further information about events in F Prime, see the
F Prime User's Guide.

==== Telemetry Ports

*Telemetry* is data regarding the state of the system.
A *telemetry port* lets a component emit telemetry.
To specify a telemetry port, you write the keyword `telemetry`,
the keyword `port`, and the port name.

As an example, here is a passive component `TelemetryPorts` with 
a telemetry port:

[source,fpp]
----
@ A component for illustrating telemetry ports
passive component TelemetryPorts {

  @ A port for emitting telemetry
  telemetry port tlmOut

}
----

Any component may have at most one telemetry port.
If a component emits telemetry (more on this below),
then a telemetry port is required.

During translation, each telemetry port is converted into 
a typed port instance with the predefined port type
`Fw.Tlm`.
The F Prime framework provides a definition for this port
in the directory `Fw/Tlm`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
--------
module Fw {
  port Tlm
}
--------

For further information about telemetry in F Prime, see the
F Prime User's Guide.

==== Parameter Ports

A *parameter* is a configurable constant that may be updated
from the ground.
The current parameter values are stored in an F Prime component
called the *parameter database*.

The special parameter behaviors, and their keywords, are as follows:

* `param` `get`: A port for getting the current value of a parameter
from the parameter database.
* `param` `set`: A port for setting the current value of a parameter
in the parameter database.

Collectively, these ports are known as *parameter ports*.
To specify a parameter port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `ParamPorts` with each
of the parameter ports:

[source,fpp]
----
@ A component for illustrating parameter ports
passive component ParamPorts {

  @ A port for getting parameter values
  param get port prmGetOut

  @ A port for setting parameter values
  param set port prmSetOut

}
----

Any component may have at most one of each kind of parameter
port.
If a component has parameters (more on this below),
then both parameter ports are required.

During translation, each parameter port is converted into 
a typed port instance with a predefined port type, as follows:

* `param` `get` uses the port `Fw.PrmGet`
* `param` `set` uses the port `Fw.PrmSet`

The F Prime framework provides definitions for these ports
in the directory `Fw/Prm`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
--------
module Fw {
  port PrmGet
  port PrmSet
}
--------

For further information about parameters in F Prime, see the
F Prime User's Guide.


==== Time Get Ports

A *time get port* lets a component get the system time from a
time component.
To specify a time get port, you write the keywords `time` `get`,
the keyword `port`, and the port name.

As an example, here is a passive component `TimeGetPorts` with 
a time get port:

[source,fpp]
----
@ A component for illustrating time get ports
passive component TimeGetPorts {

  @ A port for getting the time
  time get port timeGetOut

}
----

Any component may have at most one time get port.
If a component emits events or telemetry (more on this below),
then a time get port is required, so that the events
and telemetry points can be time stamped.

During translation, each time get port is converted into 
a typed port instance with the predefined port type
`Fw.Time`.
The F Prime framework provides a definition for this port
in the directory `Fw/Time`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
--------
module Fw {
  port Time
}
--------

For further information about time in F Prime, see the
F Prime User's Guide.

=== Internal Ports

An *internal port* is a port that a component can use to send a
message to itself.
In the ordinary case, when a component sends a message, it invokes an
output port that is connected to an async input port.
When the output port and input port reside in the same component,
it is simpler to use an internal port.

As an example, suppose we have a component 
that needs to send a message to itself.
We could construct such a component in the following way:

[source,fpp]
----
@ A data type T
type T

@ A port for sending data of type T
port P(t: T)

@ A component that sends data to itself on an async input port
active component ExternalSelfMessage {

  @ A port for sending data of type T
  async input port pIn: P

  @ A port for receiving data of type T
  output port pOut: P

}
----

This works, but if the only user of `pIn` is 
`ExternalSelfMessage`, it is cumbersome.
We need to declare two ports and connect them.
Instead, we can use an internal port, like this:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T)

}
----

When the implementation of `ExternalSelfMessage` invokes
the port `pInternal`, a message goes on its queue.
This corresponds to the behavior of `pOut` in
`ExternalSelfMessage`.
Later, when the framework dispatches the message, it
calls a handler function associated with the port.
This corresponds to the behavior of `pIn` in
`ExternalSelfMessage`.
So an internal port is like two ports (an output port
and an async input port) fused into one.

When writing an internal port, you do not use a named
port definition.
Instead, you provide the formal parameters directly.
Notice that when defining `ExternalSelfMessage` we
defined and used the port `P`, but when defining
`InternalSelfMessage` we did not.
The formal parameters of an internal port are the same
as for a <<Defining-Ports_Formal-Parameters,port definition>>, except
that none of the parameters may be a
<<Defining-Ports_Reference-Parameters,reference parameter>>.

When specifying an internal port, you may specify
<<Defining-Components_Port-Instances_Priority,priority>> and
<<Defining-Components_Port-Instances_Queue-Full-Behavior,queue full behavior>>
as for an async input port.
For example, we can add priority and queue full behavior
to `pInternal` as follows:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port,
@ with priority and queue full behavior
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T) priority 10 drop

}
----

Internal ports generate async input, so they make sense
only for `active` and `queued` components.
As an example, consider the following component
definition:

[source,fpp]
--------
type T

passive component PassiveInternalPort {

  # Internal ports don't make sense for passive components
  internal port pInternal(t: T)

}
--------

What do you think will happen if you run `fpp-check`
on this code?
Try it and see.

=== Commands

When defining an F Prime component, you may specify one or more commands.
When operating the FSW, each command is dispatched to, and handled
by, an instance of the component where it is defined.
The handling occurs in a {cpp} command handler that you write
as part of the component implementation.

For complete information about F Prime command dispatch and
handling, see the F Prime User's Guide.
Here we concentrate on how to specify commands in FPP.

==== Basic Commands

The simplest command consists of a kind followed by the keyword
`command` and a name.
The kind is one of the following:

* `async`: The command arrives on a message queue, to
be dispatched on this component's thread (if this component is active)
or on the thread of a port invocation (if this component is queued).

* `sync`: The command invokes a handler defined in this component,
and run on the thread of the caller.

* `guarded`: Similar to sync input, but the handler is
guarded by a mutual exclusion lock.

Notice that the kinds of commands are similar to the kinds of
<<Defining-Components_Port-Instances_Basic-Port-Instances,
input ports>>.
The name is the name of the command.

As an example, here is an active component called `Action`
with two commands: an async command `START` and a sync
command `STOP`.

[source,fpp]
----
@ An active component for performing an action
active component Action {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ Start the action
  async command START

  @ Stop the action
  sync command STOP

}
----

Command `START` is declared `async`.
That means that when a `START` command is dispatched
to an instance of this component, it arrives on a queue.
Later, the F Prime framework takes the message off the queue
and calls the corresponding handler on the thread
of the component.

Command `STOP` is declared `sync`.
That means that the command runs immediately on the
thread of the invoking component (for example,
a command dispatcher component).
Because the command runs immediately, its handler
should be very short.
For example, it could set a stop flag and then exit.

Notice that we defined the three
<<Defining-Components_Special-Port-Instances_Command-Ports,
command ports>>
for this component.
All three ports are required for any component that has commands.
As an example, try deleting one or more of the command ports from the
code above and running the result through `fpp-check`.

`async` commands require a message queue, so
they are allowed only for active and queued
components.
As an example, try making the `Action` component passive and
running the result through `fpp-check`.

==== Formal Parameters

When specifying a command, you may specify one or more
formal parameters.
The parameters are bound to arguments when the command
is sent to the spacecraft.
Different uses of the same command can have different
argument values.

The formal parameters of a command are the same
as for a <<Defining-Ports_Formal-Parameters,port definition>>, except
that none of the parameters may be a
<<Defining-Ports_Reference-Parameters,reference parameter>>.
As an example, here is a `Switch` component that has
two states, `ON` and `OFF`.
The component has a `SET_STATE` command for
setting the state.
The command has a single argument `state`
that specifies the new state.

[source,fpp]
----
@ The state enumeration
enum State {
  OFF @< The off state
  ON @< The on state
}

@ A switch with on and off state
active component Switch {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ Set the state
  async command SET_STATE(
    state: State @< The new state
  )

}
----

==== Opcodes

Every command in an F Prime FSW application has an *opcode*.
The opcode is a number that uniquely identifies the command.
The F Prime framework uses the opcode when dispatching commands
because it is a more compact identifier than the name.
The name is mainly for human interaction on the ground.

The opcodes associated with each component _C_
are relative to the component.
Typically the opcodes start at zero: that is, the
opcodes are 0, 1, 2, etc.
When constructing an instance _I_ of component _C_,
the framework adds a base opcode for _I_ to each relative opcode 
associated with _C_ to form
the global opcodes associated with _I_.
That way different instances of _C_ can have different opcodes
for the same commands defined in _C_.
We will have more to say about base and relative opcodes 
when we describe topologies of component instances.

If you specify a command _c_ with no explicit opcode, as in the examples
shown in the previous sections, then FPP assigns a default opcode
to _c_.
The default opcode for the first command in a component is zero.
Otherwise the default opcode for any command is one more than
the opcode of the previous command.

It is usually convenient to rely on the default opcodes.
However, you may wish to specify one or more opcodes explicitly.
To do this, you write the keyword `opcode` followed
by a numeric expression after the command name and after the
formal parameters, if any.
Here is an example:

[source,fpp]
----
@ Component for illustrating command opcodes
active component CommandOpcodes {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ This command has default opcode 0x0
  async command C1

  @ This command has explicit opcode 0x10
  async command C2(a: F32, b: U32) opcode 0x10

  @ This command has default opcode 0x11
  sync command C3

}
----

Within a component, the command opcodes must be unique.
For example, this component is incorrect because
the opcode zero appears twice:

[source,fpp]
--------
@ Component for illustrating a duplicate opcode
active component DuplicateOpcode {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ This command has opcode 0x0
  async command C1

  @ Oops! This command also has opcode 0x0
  async command C2 opcode 0x0

}
--------

==== Priority and Queue Full Behavior

When specifying an async command, you may specify
<<Defining-Components_Port-Instances_Priority,priority>> and
<<Defining-Components_Port-Instances_Queue-Full-Behavior,queue full behavior>>
as for an async input port.
You put the priority and queue full information after the command name
and after the formal parameters and opcode, if any.
Here is an example:

[source,fpp]
----
@ A component for illustrating priority and queue full behavior for async 
@ commands
active component PriorityQueueFull {

  @ Command registration
  command reg port cmdRegOut

  @ Command input
  command recv port cmdIn

  @ Command response
  command resp port cmdResponseOut

  @ Command with priority
  async command C1 priority 10

  @ Command with formal parameters and priority
  async command C2(a: U32, b: F32) priority 20

  @ Command with formal parameters, opcode, priority, and queue full behavior 
  async command C3(a: string) opcode 0x10 priority 30 drop

}
----

Priority and queue full behavior are allowed only for
`async` commands.
Try changing one of the commands in the previous example
to `sync` and see what `fpp-check` has to say about it.

=== Events

When defining an F Prime component, you may specify one or more events.
The F Prime framework converts each event into a {cpp}
function that you can call from the component implementation.
Calling the function emits a serialized event report that
you can store in an on-board file system or send to the ground.

For complete information about F Prime event
handling, see the F Prime User's Guide.
Here we concentrate on how to specify events in FPP.

==== Basic Events

The simplest event consists of the keyword `event`, a name, a severity, 
and a format string.
The name is the name of the event.
A severity is the keyword `severity` and one of the following:

* `activity` `high`: Spacecraft activity of greater importance.

* `activity` `low`: Spacecraft activity of lesser importance.

* `command`: An event related to commanding.
Primarily used by the command dispatcher.

* `diagnostic`: An event relating to system diagnosis
and debugging.

* `fatal`: An event that causes the system to abort.

* `warning` `high`: A warning of greater importance.

* `warning` `low`: A warning of lesser importance.

A format is the keyword `format` and a literal string for 
use in a formatted real-time display or event log.

As an example, here is an active component called `BasicEvents`
with a few basic events.

[source,fpp]
----
@ A component for illustrating basic events
passive component BasicEvents {

  @ Event port 
  event port eventOut

  @ Text event port
  text event port textEventOut

  @ Time get port
  time get port timeGetOut

  @ Activity low event
  event E1 severity activity low format "Event E1 occurred"

  @ Warning low event
  event E2 severity warning low format "Event E2 occurred"

  @ Warning high event
  event E3 severity warning high format "Event E3 occurred"

}
----

Notice that we defined the two
<<Defining-Components_Special-Port-Instances_Event-Ports,
event ports>>
and a
<<Defining-Components_Special-Port-Instances_Time-Get-Ports,
time get port>>
for this component.
All three ports are required for any component that has events.
As an example, try deleting one or more of these ports from the
code above and running the result through `fpp-check`.

==== Formal Parameters

When specifying an event, you may specify one or more
formal parameters.
The parameters are bound to arguments when the component
instance emits the event.
The argument values appear in the formatted text
that describes the event.

The formal parameters of an event are the same
as for a <<Defining-Ports_Formal-Parameters,port definition>>, except
that none of the parameters may be a
<<Defining-Ports_Reference-Parameters,reference parameter>>.
For each formal parameter, there must be a corresponding
replacement field in the format string.
The replacement fields for event format strings are the same as for
format strings in
<<Defining-Types_Array-Type-Definitions_Format-Strings,
type definitions>>.
The replacement fields in the format string match the event
parameters, one for one and in the same order.

As an example, here is a component with two events,
each of which has formal parameters.
Notice how the replacement fields in the event format
strings correspond to the formal parameters.

[source,fpp]
----
@ An enumeration of cases
enum Case { A, B, C }

@ An array of 3 F64 values
array F64x3 = [3] F64

@ A component for illustrating event formal parameters
passive component EventParameters {

  @ Event port 
  event port eventOut

  @ Text event port
  text event port textEventOut

  @ Time get port
  time get port timeGetOut

  @ Event E1
  @ Sample output: "Event 1 occurred with argument 42"
  event E1(
    arg1: U32 @< Argument 1
  ) \
    severity activity high \
    format "Event 1 occurred with argument {}"

  @ Event E2
  @ Sample output: "Saw value [ 0.001, 0.002, 0.003 ] for case A"
  event E2(
    case: Case @< The case
    value: F64x3 @< The value
  ) \
    severity warning low \
    format "Saw value {} for case {}" \

}
----

==== Identifiers

Every event in an F Prime FSW application has a unique
numeric identifier.
As for
<<Defining-Components_Commands_Opcodes,command opcodes>>,
the event identifiers for a component are specified
relative to the component, usually starting from
zero and counting up by one.
If you omit the identifier, then
FPP assigns a default identifier: zero for the first
event in the component; otherwise one more than the 
identifier of the previous event.

If you wish, you may explicitly specify one or more event
identifiers.
To do this, you write the keyword `id` followed
by a numeric expression immediately before the keyword `format`.
Here is an example:

[source,fpp]
----
@ Component for illustrating event identifiers
passive component EventIdentifiers {

  @ Event port 
  event port eventOut

  @ Text event port
  text event port textEventOut

  @ Time get port
  time get port timeGetOut

  @ Event E1
  @ Its identifier is 0x00
  event E1 severity activity low \
    id 0x10 \
    format "Event E1 occurred"

  @ Event E2
  @ Its identifier is 0x10
  event Event2(
    count: U32 @< The count
  ) \
    severity activity high \
    id 0x11 \
    format "The count is {}"

  @ Event E3
  @ Its identifier is 0x11
  event E3 severity activity high \
    format "event E3 occurred"

}
----

Within a component, the event identifiers must be unique.

==== Throttling

Sometimes it is necessary to throttle events, to ensure that
they do not flood the system.
For example, suppose that the FSW requests some resource _R_
at a rate _r_ of several times per second.
Suppose further that if _R_ is unavailable, then the FSW
emits a warning event.
In this case, we typically do not want the FSW to emit an unbounded number
of warnings at rate _r_; instead, we want it to emit a single warning
or a few warnings.

To achieve this behavior, you can write the keyword `throttle` and a
numeric expression after the format string.
The expression must evaluate to a constant value _n_.
After an instance of the component has emitted the event _n_ times, it will
stop emitting the event.
Here is an example:

[source,fpp]
----
@ Component for illustrating event throttling
passive component EventThrottling {

  @ Event port 
  event port eventOut

  @ Text event port
  text event port textEventOut

  @ Time get port
  time get port timeGetOut

  @ Event E
  event E severity warning high \
    format "Event E occurred" \
    throttle 10

}
----

In this example, event `E` will be throttled after the component
instance has emitted it ten times.

Once an event is throttled, the component instance will no longer
emit the event until the throttling is canceled.
Typically, the canceling happens via a FSW command.
For details, see the F Prime User's Guide.

=== Telemetry

When defining an F Prime component, you may specify one or more
*telemetry channels*.
A telemetry channel consists of a data type and an identifier.
The F Prime framework converts each telemetry into a {cpp}
function that you can call from the component implementation.
Calling the function emits a value on the channel.
Each emitted value is called a
*telemetry point*.
You can store the telemetry points in an on-board file system
or send them the ground.

For complete information about F Prime telemetry
handling, see the F Prime User's Guide.
Here we concentrate on how to specify telemetry channels in FPP.

==== Basic Telemetry

The simplest telemetry channel consists of the keyword `telemetry`,
a name, and a data type.
The name is the name of the event.
The data type is the type of data carried on the telemetry
channel.

As an example, here is an active component called `BasicTelemetry`
with a few basic events.

[source,fpp]
----
@ An array of 3 F64 values
array F64x3 = [3] F64

@ A component for illustrating basic telemetry channels
passive component BasicTelemetry {

  @ Telemetry port 
  telemetry port tlmOut

  @ Time get port
  time get port timeGetOut

  @ Telemetry channel 1
  telemetry Channel1: U32

  @ Telemetry channel 2
  telemetry Channel2: F64

  @ Telemetry channel 3
  telemetry Channel3: F64x3

}
----

Notice that we defined a
<<Defining-Components_Special-Port-Instances_Telemetry-Ports,
telemetry port>>
and a
<<Defining-Components_Special-Port-Instances_Time-Get-Ports,
time get port>>
for this component.
Both ports are required for any component that has telemetry.

==== Identifiers

Every telemetry channel in an F Prime FSW application has a unique
numeric identifier.
As for
<<Defining-Components_Commands_Opcodes,command opcodes>>
and
<<Defining-Components_Events_Identifiers,event identifiers>>,
the telemetry channel identifiers for a component are specified
relative to the component, usually starting from
zero and counting up by one.
If you omit the identifier, then
FPP assigns a default identifier: zero for the first
event in the component; otherwise one more than the 
identifier of the previous event.

If you wish, you may explicitly specify one or more 
telemetry channel identifiers.
To do this, you write the keyword `id` followed
by a numeric expression immediately after the data type.
Here is an example:

[source,fpp]
----
@ An array of 3 F64 values
array F64x3 = [3] F64

@ Component for illustrating telemetry channel identifiers
passive component TlmIdentifiers {

  @ Telemetry port
  telemetry port tlmOut

  @ Time get port
  time get port timeGetOut

  @ Telemetry channel 1
  @ Its implied identifier is 0x00
  telemetry Channel1: U32

  @ Telemetry channel 2
  @ Its identifier is 0x10
  telemetry Channel2: F64 id 0x10

  @ Telemetry channel 3
  @ Its implied identifier is 0x11
  telemetry Channel3: F64x3

}
----

Within a component, the telemetry channel identifiers must be unique.

==== Update Frequency

TODO

==== Format Strings

TODO

==== Low and High Limits

TODO

=== Parameters

TODO

=== Constants and Types

TODO

=== Include Specifiers

TODO
