== Analyzing and Translating Models

The previous section explained how to specify an FPP model:
how to divide a model into source files and how to compute the
dependencies of one or more files on other files.
This section explains the next step: how to perform analysis and
translation on part or all of an FPP model, after specifying
the model and computing its dependencies.

=== Checking Models

It is often useful to check a model for correctness, without
doing any translation.
The tool for checking models is called `fpp-check`.
If you provide one or more files as arguments, `fpp-check`
will attempt to read those files.
For example:

----
% fpp-check file1.fpp file2.fpp
----

If there are no arguments, then `fpp-check` reads from standard input.
For example:

----
% cat file1.fpp file2.fpp | fpp-check
----

If you run `fpp-check` with no arguments on the command line,
it will block and wait for standard input.
This is useful for interactive sessions, where you want
to type simple model text into the console and immediately check it.
`fpp-check` will keep reading input until (1) it encounters a parse error (more 
on this below); or (2) you terminate the input with control-D (which must be 
the first character in a line); or (3)
you terminate the program with control-C.

For larger models, the usual procedure for running `fpp-check` is as follows:

. Identify one or more files _F_ that you want to check.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. Run `fpp-check` _D_ _F_.

All the files _D_ and all the files _F_ are specified as file arguments,
separated by spaces.

When you run `fpp-check`, the following occurs:

. The tool parses all the input files, recursively resolving 
<<Specifying-Models_Include-Specifiers,include specifiers>> as it goes.
If there are any parse errors or any problems resolving include files (for 
example, a missing file), it prints an error message to standard error and 
halts with nonzero status.

. If parsing succeeds, then the tool runs semantic analysis.
If everything checks out, the tool silently returns zero status.
Otherwise it prints an error message to standard error and
halts with nonzero status.

=== Generating XML

The current code generation strategy for FPP is to generate
F Prime XML, and then to run the generated XML through the F Prime
Python autocoders to generate {cpp}.
In a future version of FPP, we will streamline this process.

*XML file names:* The table <<xml-file-names>> shows how FPP definitions are 
translated
to F Prime XML files.
The table shows only types and enums, because those are currently implemented.
As we implement more of FPP, we will extend this table.

[[xml-file-names]]
.XML File Names
|===
|FPP Definition|F Prime XML File

|Array _A_|_A_ `ArrayAi.xml`
|Enum _E_|_E_ `EnumAi.xml`
|Struct _S_|_S_ `SerializableAi.xml`
|===

For example, the FPP array definition

[source,fpp]
----
array A = [3] U32
----

is translated to the file `AArrayAi.xml`.

*Tool name:* The tool for translating FPP definitions to XML files
is called `fpp-to-xml`.

*Procedure:*
The usual procedure for running `fpp-to-xml` is as follows:

. Identify one or more files _F_ that you want to translate.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. If _D_ is empty, then run `fpp-to-xml` _F_.
. Otherwise run `fpp-to-xml -i` _D1_ `,` ... `,` _Dn_ _F_, where _Di_ are the
names of the dependencies.

For example, suppose you want to generate XML for the definitions in `c.fpp`,
If `c.fpp` has no dependencies, then run

----
% fpp-to-xml c.fpp
----

On the other hand, if `c.fpp` depends on `a.fpp` and `b.fpp`, then run

----
% fpp-to-xml -i a.fpp,b.fpp c.fpp
----

Notice that you provide the dependencies as a comma-separated list of
arguments to the option `-i`.
`-i` stands for "import."
This option tells the tool that you want to read the files in _D_ for their symbols,
but you don't want to translate them.
Only the files _F_ provided as arguments are translated.

*Tool behavior:* When you run `fpp-check`, the following occurs:

. The tool runs the same analysis 
<<Analyzing-and-Translating-Models_Checking-Models,as for `fpp-check`>>.
If there is any problem, the tool prints an error message to 
standard error and halts with nonzero status.

. If the analysis succeeds, then the tool generates XML files, one
for each definition appearing in _F_, with names as shown in the table above.
The files are written to the current directory.

*Generated import paths:*
When one FPP definition `A` depends on another definition `B`,
the generated XML file for `A` contains an XML node that imports
the generated XML file for `B`.
The tool constructs the import path from the
<<Specifying-Models_Locating-Definitions,location>> of the imported FPP symbol.

For example, suppose the file `[path prefix]/A/A.fpp` contains the following
definition, where `[path prefix]` represents the path prefix of directory
`A` starting from the root of the file system:

[source,fpp]
--------
array A = [3] B
--------

And suppose the file `[path prefix]/B/B.fpp` contains the following definition:

[source.fpp]
----
array B = [3] U32
----

If you run this command in directory `[path prefix]/A`

----
% fpp-to-xml -i ../B/B.fpp A.fpp
----

then in that directory the tool will generate a file `AArrayAi.xml` containing 
the following line:

[source,xml]
----
<import_array_type>[path prefix]/B/BArrayAi.xml</import_array_type>
----

*Removing path prefixes:*
Usually when generating XML we don't want to include the system-specific part 
of the path prefix.
Instead, we want the path to be specified relative to some known place, for 
example
the root of the F Prime repository or a project repository.

To remove the prefix _prefix_ from generated paths, use the option
`-p` _prefix_ .
To continue the previous example, running

----
fpp-to-xml -i ../B/B.fpp -p [path prefix] A.fpp
----

generates a file `AArrayAi.xml` containing the line

[source,xml]
----
<import_array_type>B/BArrayAi.xml</import_array_type>
----

Notice that the path prefix `[path prefix]/` has been removed.

To specify multiple prefixes, separate them with commas:

----
fpp-to-xml -p prefix1,prefix2, ...
----

For each generated path, the tool will delete the longest prefix
that matches a prefix in the list.

*More options:* The following additional options are available
when running `fpp-to-xml`:

* `-d` _dir_ : Use _dir_ instead of the current directory as 
the output directory for writing files.
For example,
+
----
fpp-to-xml -d xml ...
----
+
writes output files
to the directory `xml` (which must already exist).

* `-n` _file_ : Write the names of the generated XML files
to _file_.
This is useful for collecting autocoder build dependencies.

* `-s` _size_ : Specify a default string size.
For example,
+
----
fpp-to-xml -s 40 ...
----
+
FPP allows string types with no specified size, and F Prime XML
does not.
So when generating code we need to provide a default size
to use when FPP doesn't specify the size.
If you don't specify the `-s` option, then the tool uses
an automatic default of 80.

*Standard input:* Instead of providing named files as arguments,
you can provide FPP source on standard input, as described
for <<Analyzing-and-Translating-Models_Checking-Models,`fpp-check`>>.

*XML limitations:* The XML translation currently has several
limitations.
For more information, see the text marked *XML limitations* in the following 
sections:

* <<Defining-Types_Struct-Type-Definitions,Struct Type Definitions>>

* <<Defining-Enums,Defining Enums>>

=== Generating C Plus Plus

As discussed in the previous section, our current strategy is to generate XML 
and use the F Prime autocoders to generate
{cpp}.
However, we make an exception for constant definitions: for those, we generate 
{cpp} for those directly from FPP.
The reason is that the F Prime autocoder provides no capability
to specify constants in XML.

*Tool name:* The tool for translating FPP to {cpp} is called
`fpp-to-cpp`.

*Procedure:* 
The usual procedure for running `fpp-to-cpp` is as follows:

. Identify one or more files _F_ that you want to translate.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. If _D_ is empty, then run `fpp-to-cpp` _F_.
. Otherwise run `fpp-to-cpp -i` _D1_ `,` ... `,` _Dn_ _F_, where _Di_ are the
names of the dependencies.

Except for the tool name, this procedure is identical to the one given for 
<<Analyzing-and-Translating-Models_Generating-XML,generating XML>>.
See that section for examples of the procedure.

*Input:* As with the tools described above, you can provide input to 
`fpp-to-cpp`
either through named files or through standard input.

*Tool behavior:*
For now this tool just generates {cpp} constants.
In the future it will do more.
(Eventually, it should replace `fpp-to-xml` and the Python autocoders.)

`fpp-to-cpp` extracts <<Defining-Constants,constant definitions>>
from the source files _F_.
It generates files `FppConstants.hpp` and `FppConstants.cpp`
containing {cpp} definitions of the constants.
By including and/or linking against he generated {cpp} files,
you can refer to the constants defined in the FPP model
in your FSW implementation code.

To keep things simple, only numeric, string, and Boolean constants are 
translated;
struct and array constants are ignored.
For example, the following constant is not translated, because
it is an array:

[source,fpp]
----
constant a = [ 1, 2, 3 ]
----

To translate array constants, you must expand them to values
that are translated, like this:

[source,fpp]
----
constant a0 = 1
constant a1 = 2
constant a2 = 3
constant a = [ a0, a1, a2 ]
----

Constants are translated as follows:

* Integer constants become enumeration constants.
* Floating-point constants become `const` floating-point variables.
* `bool` point constants become `const bool` variables.
* `string` constants become `const char* const` variables initialized
with string literals.

As an example, try this:

----
% fpp-to-cpp
@ Constant a
constant a = 1
@ Constant b
constant b = 2.0
@ Constant c
constant c = true
@ Constant d
constant d = "abcd"
^D
----

You should see files `FppConstants.hpp` and `FppConstants.cpp`
in the current directory.
Examine them to confirm your understanding of how the translation
works
Notice how the FPP annotations are translated to comments.
(We also remarked on this in the section on 
<<Writing-Comments-and-Annotations_Annotations,writing annotations>>.)

*Setting the include guard prefix:* By default, the include guard
for `FppConstants.hpp` is `FppConstants_HPP`.
This works fine if you generate one constant file
for your whole model.
However, if you generate separate constant files for
separate source files in your model, and you include
the files in your FSW application, then having multiple
files with the same guard is not a good idea.
It can cause symbols to be improperly excluded from the compilation,
leading to compilation failure.

To avoid this problem, use the option `-g` _guard-prefix_.
This options says to add _guard-prefix_ to the include
guard for `FppConstants.hpp`.
For example, if you run `fpp-to-cpp -g Commands ...`,
then the include guard will be `Commands_FppConstants_HPP`.

*More options:* The following additional options are available
when running `fpp-to-cpp`:

* `-d` _dir_ : Use _dir_ instead of the current directory as 
the output directory for writing files.
This is similar to the `-d` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

* `-n` _file_ : Write the names of the generated XML files
to _file_.
This is similar to the `-n` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

* `-p` _path-prefixes_ : Remove the longest of one or more path prefixes from
generated header paths.
To specify multiple prefixes, separate them with commas (and no spaces).
This is similar to the `-p` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

=== Implementing Abstract Types

An <<Defining-Types_Abstract-Type-Definitions,abstract type definition>>
represents a {cpp} class that you write by hand.
When you use an abstract type _T_ in an FPP definition _D_ (for example, 
as the member type of an array definition)
and you translate _D_ to XML, then the 
generated XML node for _D_ contains an `include_header` node that
includes a header file for _T_.

As an example, try this:

----
% fpp-to-xml -p $PWD
type T
array A = [3] T
^D
----

Notice that we used the option `-p $PWD`.
This is to make the generated include path relative to the current directory.

Now run

----
% cat AArrayAi.xml
----

You should see the following line in the generated XML:

[source,xml]
----
<include_header>T.hpp</include_header>
----

This line says that when the F Prime autocoder translates this XML file
to a {cpp} class, in order to compile that class, a header file `T.hpp`
must exist in the current directory. It is up to you to provide that header
file.

When implementing an abstract type `T` in {cpp}, you must define
a class that extends `Fw::Serializable` from the F Prime framework.
Your class definition must include the following:

* An implementation of the virtual function
+
[source,c++]
----
Fw::SerializeStatus T::serialize(Fw::SerializeBufferBase&) const`
----
+
that specifies how to *serialize* a class instance (i.e., convert a class 
instance to a byte string).

* An implementation of the function
+
[source,c++]
----
Fw::SerializeStatus T::serialize(Fw::SerializeBufferBase&)`
----
+
that specifies how to *deserialize* a class instance (i.e., reconstruct a class
instance from a byte string).

* A constant `T::SERIALIZED_SIZE` that specifies the size in bytes
of a byte string serialized from the class.

* A zero-argument constructor `T()`.

* An overloaded equality operator
+
----
bool operator==(const T& that) const;
----

Here is a minimal complete implementation of an abstract type `T`.
It has one field `x` of type `U32` and no methods other than
those required by F Prime.
We have made `T` a {cpp} struct (rather than a class) so that
all members are public by default.

----
// A minimal implementation of abstract type T

#ifndef T_HPP
#define T_HPP

// Include Fw/Types/Serializable.fpp from the F Prime framework
#include "Fw/Types/Serializable.hpp"

struct T : public Fw::Serializable { // Extend Fw::Serializable

  // Define some shorthand for F Prime types
  typedef Fw::SerializeStatus SS;
  typedef Fw::SerializeBufferBase B;

  // Define the constant SERIALIZED_SIZE
  enum Constants { SERIALIZED_SIZE = sizeof(U32) };

  // Provide a zero-argument constructor
  T() : x(0) { }

  // Define a comparison operator
  bool operator==(const T& that) const { return this->x == that.x; }

  // Define the virtual serialize method
  SS serialize(B& b) const { return b.serialize(x); }

  // Define the virtual deserialize method
  SS deserialize(B& b) { return b.deserialize(x); }

  // Provide some data
  U32 x;

};

#endif
----

=== Translating XML to FPP

TODO

