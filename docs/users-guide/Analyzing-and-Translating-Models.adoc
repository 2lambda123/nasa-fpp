== Analyzing and Translating Models

The previous section explained how to specify an FPP model:
how to divide a model into source files and how to compute the
dependencies of one or more files on other files.
This section explains the next step: how to perform analysis and
translation on part or all of an FPP model, after specifying
the model and computing its dependencies.

=== Checking Models

It is often useful to check a model for correctness, without
doing any translation.
The tool for checking models is called `fpp-check`.
If you provide one or more files as arguments, `fpp-check`
will attempt to read those files.
For example:

----
% fpp-check file1.fpp file2.fpp
----

If there are no arguments, then `fpp-check` reads from standard input.
For example:

----
% cat file1.fpp file2.fpp | fpp-check
----

If you run `fpp-check` with no arguments on the command line,
it will block and wait for standard input.
This is useful for interactive sessions, where you want
to type simple model text into the console and immediately check it.
`fpp-check` will keep reading input until (1) it encounters a parse error (more 
on this below); or (2) you terminate the input with control-D (which must be 
the first character in a line); or (3)
you terminate the program with control-C.

For larger models, the usual procedure for running `fpp-check` is as follows:

. Identify one or more files _F_ that you want to check.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. Run `fpp-check` _D_ _F_.

All the files _D_ and all the files _F_ are specified as file arguments,
separated by spaces.

When you run `fpp-check`, the following occurs:

. The tool parses all the input files, recursively resolving 
<<Specifying-Models_Include-Specifiers,include specifiers>> as it goes.
If there are any parse errors or any problems resolving include files (for 
example, a missing file), it prints an error message to standard error and 
halts with nonzero status.

. If parsing succeeds, then the tool runs semantic analysis.
If everything checks out, the tool silently returns zero status.
Otherwise it prints an error message to standard error and
halts with nonzero status.

=== Generating XML

The current strategy is to generate
F Prime XML, and then to run the generated XML through the F Prime
Python autocoders to generate {cpp}.
In a future version of FPP, we will streamline this process.

*XML file names:* The table <<xml-file-names>> shows how FPP definitions are 
translated
to F Prime XML files.
The table shows types, enums, and ports because those are the features
currently implemented.
As we implement more of FPP, we will extend this table.

[[xml-file-names]]
.XML File Names
|===
|FPP Definition|F Prime XML File

|Array _A_|_A_ `ArrayAi.xml`
|Enum _E_|_E_ `EnumAi.xml`
|Struct _S_|_S_ `SerializableAi.xml`
|Port _P_|_P_ `PortAi.xml`
|===

For example, the FPP array definition

[source,fpp]
----
array A = [3] U32
----

is translated to the file `AArrayAi.xml`.

*Tool name:* The tool for translating FPP definitions to XML files
is called `fpp-to-xml`.

*Procedure:*
The usual procedure for running `fpp-to-xml` is as follows:

. Identify one or more files _F_ that you want to translate.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. If _D_ is empty, then run `fpp-to-xml` _F_.
. Otherwise run `fpp-to-xml -i` _D1_ `,` ... `,` _Dn_ _F_, where _Di_ are the
names of the dependencies.

For example, suppose you want to generate XML for the definitions in `c.fpp`,
If `c.fpp` has no dependencies, then run

----
% fpp-to-xml c.fpp
----

On the other hand, if `c.fpp` depends on `a.fpp` and `b.fpp`, then run

----
% fpp-to-xml -i a.fpp,b.fpp c.fpp
----

Notice that you provide the dependencies as a comma-separated list of
arguments to the option `-i`.
`-i` stands for "import."
This option tells the tool that you want to read the files in _D_ for their symbols,
but you don't want to translate them.
Only the files _F_ provided as arguments are translated.

*Tool behavior:* When you run `fpp-check`, the following occurs:

. The tool runs the same analysis 
<<Analyzing-and-Translating-Models_Checking-Models,as for `fpp-check`>>.
If there is any problem, the tool prints an error message to 
standard error and halts with nonzero status.

. If the analysis succeeds, then the tool generates XML files, one
for each definition appearing in _F_, with names as shown in the table above.
The files are written to the current directory.

*Generated import paths:*
When one FPP definition `A` depends on another definition `B`,
the generated XML file for `A` contains an XML node that imports
the generated XML file for `B`.
The tool constructs the import path from the
<<Specifying-Models_Locating-Definitions,location>> of the imported FPP symbol.

For example, suppose the file `[path prefix]/A/A.fpp` contains the following
definition, where `[path prefix]` represents the path prefix of directory
`A` starting from the root of the file system:

[source,fpp]
--------
array A = [3] B
--------

And suppose the file `[path prefix]/B/B.fpp` contains the following definition:

[source.fpp]
----
array B = [3] U32
----

If you run this command in directory `[path prefix]/A`

----
% fpp-to-xml -i ../B/B.fpp A.fpp
----

then in that directory the tool will generate a file `AArrayAi.xml` containing 
the following line:

[source,xml]
----
<import_array_type>[path prefix]/B/BArrayAi.xml</import_array_type>
----

*Removing path prefixes:*
Usually when generating XML we don't want to include the system-specific part 
of the path prefix.
Instead, we want the path to be specified relative to some known place, for 
example
the root of the F Prime repository or a project repository.

To remove the prefix _prefix_ from generated paths, use the option
`-p` _prefix_ .
To continue the previous example, running

----
fpp-to-xml -i ../B/B.fpp -p [path prefix] A.fpp
----

generates a file `AArrayAi.xml` containing the line

[source,xml]
----
<import_array_type>B/BArrayAi.xml</import_array_type>
----

Notice that the path prefix `[path prefix]/` has been removed.

To specify multiple prefixes, separate them with commas:

----
fpp-to-xml -p prefix1,prefix2, ...
----

For each generated path, the tool will delete the longest prefix
that matches a prefix in the list.

*More options:* The following additional options are available
when running `fpp-to-xml`:

* `-d` _dir_ : Use _dir_ instead of the current directory as 
the output directory for writing files.
For example,
+
----
fpp-to-xml -d xml ...
----
+
writes output files
to the directory `xml` (which must already exist).

* `-n` _file_ : Write the names of the generated XML files
to _file_.
This is useful for collecting autocoder build dependencies.

* `-s` _size_ : Specify a default string size.
For example,
+
----
fpp-to-xml -s 40 ...
----
+
FPP allows string types with no specified size, and F Prime XML
does not.
So when generating code we need to provide a default size
to use when FPP doesn't specify the size.
If you don't specify the `-s` option, then the tool uses
an automatic default of 80.

*Standard input:* Instead of providing named files as arguments,
you can provide FPP source on standard input, as described
for <<Analyzing-and-Translating-Models_Checking-Models,`fpp-check`>>.

*XML limitations:* The XML translation currently has several
limitations.
For more information, see the text marked *XML limitations* in the following 
sections:

* <<Defining-Types_Struct-Type-Definitions,Struct Type Definitions>>

* <<Defining-Enums,Defining Enums>>

=== Generating C Plus Plus

As discussed in the previous section, our current strategy is to generate XML 
and to use the F Prime autocoders to generate
{cpp}.
However, we make an exception for constant definitions: for those, we generate 
{cpp} directly from FPP.
The reason is that the F Prime XML representation has no way to specify 
symbolic constants.

*Tool name:* The tool for translating FPP to {cpp} is called
`fpp-to-cpp`.

*Procedure:* 
The usual procedure for running `fpp-to-cpp` is as follows:

. Identify one or more files _F_ that you want to translate.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. If _D_ is empty, then run `fpp-to-cpp` _F_.
. Otherwise run `fpp-to-cpp -i` _D1_ `,` ... `,` _Dn_ _F_, where _Di_ are the
names of the dependencies.

Except for the tool name, this procedure is identical to the one given for 
<<Analyzing-and-Translating-Models_Generating-XML,generating XML>>.
See that section for examples of the procedure.

*Input:* As with the tools described above, you can provide input to 
`fpp-to-cpp`
either through named files or through standard input.

*Tool behavior:*
For now this tool just generates {cpp} constants.
In the future it will do more.
(Eventually, it will replace `fpp-to-xml` and the Python {cpp} autocoders.)

`fpp-to-cpp` extracts <<Defining-Constants,constant definitions>>
from the source files _F_.
It generates files `FppConstants.hpp` and `FppConstants.cpp`
containing {cpp} translations of the constants.
By including and/or linking against these files,
you can use constants defined in the FPP model
in your FSW implementation code.

To keep things simple, only numeric, string, and Boolean constants are 
translated;
struct and array constants are ignored.
For example, the following constant is not translated, because
it is an array:

[source,fpp]
----
constant a = [ 1, 2, 3 ]
----

To translate array constants, you must expand them to values
that are translated, like this:

[source,fpp]
----
constant a0 = 1
constant a1 = 2
constant a2 = 3
constant a = [ a0, a1, a2 ]
----

Constants are translated as follows:

* Integer constants become enumeration constants.
* Floating-point constants become `const` floating-point variables.
* `bool` point constants become `const bool` variables.
* `string` constants become `const char* const` variables initialized
with string literals.

As an example, try this:

----
% fpp-to-cpp
@ Constant a
constant a = 1
@ Constant b
constant b = 2.0
@ Constant c
constant c = true
@ Constant d
constant d = "abcd"
^D
----

You should see files `FppConstants.hpp` and `FppConstants.cpp`
in the current directory.
Examine them to confirm your understanding of how the translation
works
Notice how the FPP annotations are translated to comments.
(We also remarked on this in the section on 
<<Writing-Comments-and-Annotations_Annotations,writing annotations>>.)

*Setting the include guard prefix:* By default, the include guard
for `FppConstants.hpp` is `FppConstants_HPP`.
This works fine if you generate one constant file
for your whole model.
However, if you generate separate constant files for
separate source files in your model, then having multiple
files with the same guard is not a good idea.
If one compilation step tries to include both files, then the second
inclusion will fail.
This will likely cause a compilation failure,
because symbols defined in the excluded file will be
reported as undefined.

To avoid this problem, use the option `-g` _guard-prefix_.
This options says to add _guard-prefix_ to the include
guard for `FppConstants.hpp`.
For example, if you run `fpp-to-cpp -g Commands ...`,
then the include guard will be `Commands_FppConstants_HPP`.

*More options:* The following additional options are available
when running `fpp-to-cpp`:

* `-d` _dir_ : Use _dir_ instead of the current directory as 
the output directory for writing files.
This is similar to the `-d` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

* `-n` _file_ : Write the names of the generated XML files
to _file_.
This is similar to the `-n` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

* `-p` _path-prefixes_ : Remove the longest of one or more path prefixes from
generated header paths.
To specify multiple prefixes, separate them with commas (and no spaces).
This is similar to the `-p` option for
<<Analyzing-and-Translating-Models_Generating-XML, `fpp-to-xml`>>.

=== Implementing Abstract Types

When translating to XML and then {cpp}, an
<<Defining-Types_Abstract-Type-Definitions,abstract type definition>>
represents a {cpp} class that you write directly in {cpp}.
When you use an abstract type _T_ in an FPP definition _D_ (for example, as the 
member type of an array definition)
and you translate _D_ to XML, then the generated XML node for _D_ contains an 
`include_header` node that
includes a header file for _T_.

As an example, try this:

----
% fpp-to-xml -p $PWD
type T
array A = [3] T
^D
----

Notice that we used the option `-p $PWD`.
This is to make the generated include path relative to the current directory.

Now run

----
% cat AArrayAi.xml
----

You should see the following line in the generated XML:

[source,xml]
----
<include_header>T.hpp</include_header>
----

This line says that when the F Prime autocoder translates this XML file
to a {cpp} class, in order to compile that class, a header file `T.hpp`
must exist in the current directory. It is up to you to provide that header
file.

When implementing an abstract type `T` in {cpp}, you must define
a class that extends `Fw::Serializable` from the F Prime framework.
Your class definition must include the following:

* An implementation of the virtual function
+
----
Fw::SerializeStatus T::serialize(Fw::SerializeBufferBase&) const`
----
+
that specifies how to *serialize* a class instance (i.e., convert a class 
instance to a byte string).

* An implementation of the function
+
----
Fw::SerializeStatus T::serialize(Fw::SerializeBufferBase&)`
----
+
that specifies how to *deserialize* a class instance (i.e., reconstruct a class
instance from a byte string).

* A constant `T::SERIALIZED_SIZE` that specifies the size in bytes
of a byte string serialized from the class.

* A zero-argument constructor `T()`.

* An overloaded equality operator
+
----
bool operator==(const T& that) const;
----

Here is a minimal complete implementation of an abstract type `T`.
It has one member variable `x` of type `U32` and no methods other than
those required by F Prime.
We have made `T` a {cpp} struct (rather than a class) so that
all members are public by default.

----
// A minimal implementation of abstract type T

#ifndef T_HPP
#define T_HPP

// Include Fw/Types/Serializable.fpp from the F Prime framework
#include "Fw/Types/Serializable.hpp"

struct T : public Fw::Serializable { // Extend Fw::Serializable

  // Define some shorthand for F Prime types
  typedef Fw::SerializeStatus SS;
  typedef Fw::SerializeBufferBase B;

  // Define the constant SERIALIZED_SIZE
  enum Constants { SERIALIZED_SIZE = sizeof(U32) };

  // Provide a zero-argument constructor
  T() : x(0) { }

  // Define a comparison operator
  bool operator==(const T& that) const { return this->x == that.x; }

  // Define the virtual serialize method
  SS serialize(B& b) const { return b.serialize(x); }

  // Define the virtual deserialize method
  SS deserialize(B& b) { return b.deserialize(x); }

  // Provide some data
  U32 x;

};

#endif
----

=== Translating XML to FPP

The FPP tool suite provides a capability to translate F Prime
XML files to FPP.
Its purpose is to address the following case:

. You have already developed an F Prime model in XML.
. You wish to translate the model to FPP so you can use FPP going forward.

Currently translation for types, enumerations, and ports is available.
You can translate these elements in your XML model now,
and use FPP to represent them going forward.
To integrate these elements written in FPP with other model
elements (components and topologies) written directly in XML, use the
<<Analyzing-and-Translating-Models_Generating-XML,FPP to XML translation 
described above>> to generate XML from the FPP part.
Later, when more of FPP becomes available, you can translate more
of your model to FPP.

The XML-to-FPP translation is designed to do most of the work in translating an 
existing XML model into FPP.
As discussed below, some manual effort will still be required,
because the FPP and XML representations are not identical.
The good news is that this is a one-time effort: you can do it once
and then use the FPP version thereafter.

*Tool name:* The tool for translating XML to FPP is called
`fpp-from-xml`.

*Tool behavior:*
Unlike the tools described above, `fpp-from-xml` does not read
from standard input.
To use it, you must name one or more XML files on the command line.
The reason is that the XML parsing library used by the tool requires
named files.
The tool reads the XML files you name, translates them, and
writes the result to standard output.

As an example, try this:

----
% fpp-to-xml
struct S { x: U32, y: F32 }
^D
% fpp-from-xml SSerializableAi.xml 
struct S {
  x: U32
  y: F32
}
----

*Default values:*
There are two issues to note in connection with translating default 
values.

First, in FPP, every definition has a default value, but
the default value need not be given explicitly:
if you provide no explicit default value, then an implicit default is used.
By contrast, in F Prime XML, (1) you _must_ supply default values for array
elements, and (2) you _may not_ supply default values for struct members
or enumerations. (This is an unfortunate inconsistency of the XML 
representation.)
To keep the translation simple, if default values are present in the XML
representation, then `fpp-from-xml` translates them to explicit values,
even if they could be made implicit.

Here is an example:

----
% fpp-to-xml
array A = [3] U32
^D
% fpp-from-xml AArrayAi.xml
array A = [3] U32 default [
                            0
                            0
                            0
                          ]
----

Notice that the implicit default value `[ 0, 0, 0 ]` becomes
explicit when translating to XML and back to FPP.

Second, to keep the translation simple, only numeric values,
string values, and Boolean values are translated.
Values of array, struct, enum, and abstract type are not translated.
The reason is that the types of these values cannot be easily inferred from the 
XML representation.
When a default value is not translated, the translator inserts an annotation
identifying what was not translated, so that you can do the translation
yourself.

For example, try this:

----
% fpp-to-xml
type T
array A = [3] T  
^D
% fpp-from-xml AArrayAi.xml 
@ FPP from XML: could not translate array value [ T(), T(), T() ]
array A = [3] T
----

The tool cannot translate the abstract type `T`.
So it adds an annotation stating that.
In this case, `T()` is the default value associated with the
abstract type `T`, so using the implicit default is correct.
So in this case, just delete the annotation.

Here is another example:

----
% fpp-to-xml
array A = [2] U32
array B = [2] A default [ [ 1, 2 ], [ 3, 4 ] ]
^D
% fpp-from-xml BArrayAi.xml
@ FPP from XML: could not translate array value [ A(1, 2), A(3, 4) ]
array B = [2] A
----

Here XML representation of the array values `[ 1, 2 ]` and `[ 3, 4 ]`
uses the {cpp} constructor calls `A(1, 2)` and `A(3, 4)`.
When translating `BArrayAi.xml` `fpp-from-xml` doesn't know how to translate 
those values, because it doesn't have any information about the type `A`.
So it omits the FPP default array value and reports the XML default element 
values in the annotation.
That way, you can manually construct a default value in FPP.

*Inline type definitions:*
The following F Prime XML formats may include definitions of arrays
and enumerations:

* The F Prime Serializable XML format can
contain arrays and enumerations as member types.
The array sizes and enumerated constants are specified inline, as
part of the member definition.

* The F Prime Port XML format can contain enumerations
as parameter types or as the return type.
Again the enumerated constants are specified inline.

We call such definitions *inline array and enum definitions*, because each one
is embedded in some other definition (the definition of a serializable type or 
of a port).

FPP does not represent inline array and enum definitions directly.
In FPP, array and enum definitions are always named, so they can be reused.
Therefore, when translating a Serializable XML file or Port XML file that 
contains inline definitions, `fpp-to-xml` does the following: (1) translate
each inline definition to a named FPP type; and (2) use the named types in the
translated FPP struct type or port.

For example, here is an F Prime Serializable XML type
`N::S` containing a member `m` that is an array of 10 `U32`
values:

----
% cat > SSerializableAi.xml
<serializable namespace="N" name="S">
  <members>
    <member name="m" type="U32" size="10"/>
  </members>
</serializable>
^D
----

Running `fpp-from-xml` yields the following:

----
% fpp-from-xml SSerializableAi.xml
module N {

  array S_m = [10] U32
  
  struct S {
    m: S_m
  }

}
----

Notice the following:

. The namespace `N` in the XML is translated to module `N` in FPP.
. The Serializable type `N::S` in the XML is translated to the struct type 
`N.S` in FPP.
. The translator has generated an array type `N.S_m` to represent the
type of member `m` of struct `N.S`.
. The translator has given member `m` of struct `N.S` the type `N.S_m`.

The handling of inline enumeration types and of formal parameters in ports is 
similar.

If you have an existing XML model, and that model contains Serializable
XML files or Port XML files with inline arrays or enums, then we suggest the 
following procedure for translating the model to FPP:

. Run `fpp-from-xml` as described above.
. Refactor your XML model to use the XML types generated in step 1.
This may require changes to your {cpp} code.
For example, inline XML enums and XML enum types generate
slightly different code.
Therefore, you will need to revise any
uses of the old inline enums to match the new format.
Do this step incrementally, making sure that all your regression tests pass at 
each step.
During this step, you can replace auto-generated names such as `S_m`
with more meaningful names.
. Once you have the XML model in the required form, run `fpp-from-xml`
again to generate an FPP model _M_.
If you have done step 2 correctly, then you should be able to
replace your handwritten XML with the result of running `fpp-to-xml`
on _M_.

*Format strings:*
`fpp-from-xml` translates XML format strings to FPP
format strings, if it can.
Here is an example:

----
% fpp-to-xml
array A = [3] F32 format "{f}"
^D
----

This will generate a file `AArrayAi.xml` containing the line

----
<format>%f</format>
----

which is the XML representation of the format.

Now try this:

----
% fpp-from-xml AArrayAi.xml
array A = [3] F32 default [
                            0.0
                            0.0
                            0.0
                          ] format "{f}"
----

The XML format `%f` is translated back to the FPP format `{f}`.

If the tool cannot translate the format, it will insert an annotation
stating that. For example, `%q` is not a format recognized by
FPP, so a format containing this string won't be translated:

----
% cat > AArrayAi.xml
<array name="A">
  <type>F32</type>
  <size>1</size>
  <format>%q</format>
  <default>
    <value>0.0</value>
  </default>
</array>
^D
% fpp-from-xml AArrayAi.xml 
@ FPP from XML: could not translate format string "%q"
array A = [1] F32 default [
                            0.0
                          ]
----

*Import and include directives:*
Import and include directives appearing in the XML source are ignored
in the translation.
These directives represent dependencies between XML files, which
become dependencies between FPP source files in the FPP translation.
Once the XML-to-FPP translation is done, you can handle these
dependencies in the ordinary way for FPP, as discussed in the
section on <<Specifying-Models,specifying models>>.
