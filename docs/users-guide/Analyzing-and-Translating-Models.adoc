== Analyzing and Translating Models

The previous section explained how to specify an FPP model:
how to divide a model into source files and how to compute the
dependencies of one or more files on other files.
This section explains how to perform analysis and
translation of FPP models.

=== Checking Models

The tool for checking models is called `fpp-check`.
If you provide one or more files as arguments, `fpp-check`
will attempt to read those files.
For example:

----
% fpp-check file1.fpp file2.fpp
----

If there are no arguments, then `fpp-check` reads from standard input.
For example:

----
% cat file1.fpp file2.fpp | fpp-check
----

If you run `fpp-check` with no arguments on the command line,
it will block and wait for standard input.
This is useful for interactive sessions, where you want
to type simple model text into the console and immediately check it.
`fpp-check` will keep reading input until (1) it encounters a parse error (more 
on this below); or (2) you terminate the input with control-D (which must be 
the first character in a line); or (3)
you terminate the program with control-C.

For larger models, the usual procedure for running `fpp-check` is as follows:

. Identify one or more files _F_ that you want to check.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. Run `fpp-check` _D_ _F_.

All the files _D_ and all the files _F_ are specified as file arguments,
separated by spaces.

When you run `fpp-check`, the following occurs:

. The tool parses all the input files, recursively resolving 
<<Specifying-Models_Include-Specifiers,include specifiers>> as it goes.
If there are any parse errors or any problems resolving include files (for 
example, a missing file), it prints an error message to standard error and 
halts with nonzero status.

. If parsing succeeds, then the tool runs semantic analysis.
If everything checks out, the tool silently returns zero status.
Otherwise it prints an error message to standard error and
halts with nonzero status.

=== Generating XML

The current code generation strategy for FPP is to generate
F Prime XML, and then to run the generated XML through the F Prime
Python autocoders to generate {cpp}.
In a future version of FPP, we will streamline this process.

*XML file names:* The table <<xml-file-names>> shows how FPP definitions are 
translated
to F Prime XML files.
The table shows only types and enums, because those are currently implemented.
As we implement more of FPP, we will extend this table.

[[xml-file-names]]
.XML File Names
|===
|FPP Definition|F Prime XML File

|Array _A_|_A_ `ArrayAi.xml`
|Enum _E_|_E_ `EnumAi.xml`
|Struct _S_|_S_ `SerializableAi.xml`
|===

For example, the FPP array definition

[source,fpp]
----
array A = [3] U32
----

is translated to the file `AArrayAi.xml`.

*Tool name:* The tool for translating FPP definitions to XML files
is called `fpp-to-xml`.

*Procedure:*
The the usual procedure for running `fpp-to-xml` is as follows:

. Identify one or more files _F_ that you want to translate.
. <<Specifying-Models_Computing-Dependencies,Compute the dependencies>> _D_ of _F_.
. If _D_ is empty, then run `fpp-to-xml` _F_.
. Otherwise run `fpp-to-xml -i` _D1_ `,` ... `,` _Dn_ _F_, where _Di_ are the
names of the dependencies.

For example, suppose you want to generate XML for the definitions in `c.fpp`,
If `c.fpp` has no dependencies, then run

----
% fpp-to-xml c.fpp
----

On the other hand, if `c.fpp` depends on `a.fpp` and `b.fpp`, then run

----
% fpp-to-xml -i a.fpp,b.fpp c.fpp
----

Notice that you provide the dependencies as a comma-separated list of
arguments to the option `-i`.
`-i` stands for "import."
This option tells the tool that you want to read the files in _D_ for their symbols,
but you don't want to translate them.
Only the files _F_ provided as arguments are translated.

*Tool Behavior:* When you run `fpp-check`, the following occurs:

. The tool runs the same analysis 
<<Analyzing-and-Translating-Models_Checking-Models,as for `fpp-check`>>.
If there is any problem, the tool prints an error message to 
standard error and halts with nonzero status.

. If the analysis succeeds, then the tool generates XML files, one
for each definition appearing in _F_, with names as shown in the table above.
The files are written to the current directory.

*More Options:* The following additional options are available
when running `fpp-to-xml`:

* `-d` _dir_ : Use _dir_ instead of the current directory as 
the output directory for writing files.
For example,
+
----
fpp-to-xml -d xml ...
----
+
writes output files
to the directory `xml` (which must already exist).

* `-n` _file_ : Write the names of the generated XML files
to _file_.
This is useful for collecting autocoder build dependencies.

* `-p` _prefix1_ `,` _prefix2_ `, ...` :
Delete the specified path prefixes from `import` declarations
in the generated XML.
For example, if your F Prime repository lives at `$FPRIME`
on your local machine, by default all path prefixes will start
with `$FPRIME`.
Usually when generating code we want to delete this local prefix.
We do that with
+
----
fpp-to-xml -p $FPRIME ...
----
+
To specify multiple prefixes, separate them with commas.

* `-s` _size_ : Specify a default string size.
For example,
+
----
fpp-to-xml -s 40 ...
----
+
FPP allows string types with no specified size, and F Prime XML
does not.
So when generating code we need to provide a default size
to use when FPP doesn't specify the size.
If you don't specify the `-s` option, then the tool uses
an automatic default of 80.

*Standard input:* Instead of providing named files as arguments,
you can provide FPP source on standard input, as described
for <<Analyzing-and-Translating-Models_Checking-Models,`fpp-check`>>.

*XML limitations:* The XML translation currently has several
limitations.
For more information, see the text marked *XML limitations* in the following 
sections:

* <<Defining-Types_Struct-Type-Definitions,Struct Type Definitions>>

* <<Defining-Enums,Defining Enums>>

=== Generating C Plus Plus

TODO

Explain how abstract types work in {cpp}.
When implementing an abstract type in {cpp}, you must provide

* An implementation of the Serializable virtual classes
* A SERIALIZABLE_SIZE
* A zero-argument constructor

=== Translating XML to FPP

TODO

