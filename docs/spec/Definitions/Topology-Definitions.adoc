=== Topology Definitions

A *topology definition* defines an F Prime topology,
that is, a set of component instances and the connections
between their ports.

==== Syntax

`topology` 
<<Lexical-Elements_Identifiers,_identifier_>>
`{` _topology-member-sequence_ `}`

_topology-member-sequence_ is an
<<Element-Sequences,element sequence>> in 
which each element is a *topology member*,
and the terminating punctuation is a semicolon.
A topology member is one of the following:

* A <<Definitions_Topology-Import-Specifiers,topology import specifier>>

* A <<Definitions_Component-Instance-Specifiers,component 
instance specifier>>

* A <<Definitions_Connection-Graph-Definitions,connection graph definition>>

==== Semantics

===== Resolving Topology Definitions

FPP uses the following algorithm to resolve a topology definition _D_
to a topology _T_:

. Let _I_ be the set of 
<<Definitions_Component-Instance-Specifiers,instances>> 
(both public and private) appearing in _D_.

. Let _C_ be the disjoint union of all connections specified in any
<<Definitions_Connection-Graph-Definitions,connection graphs>> of _D_.
For example, if graph _G1_
contains _n_ connections between port _p_ and port _p'_, and graph _G2_
contains _m_ connections between port _p_ and port _p'_, then the disjoint
union _C_ of the connections in _G1_ and _G2_ contains _n + m_ connections
between port _p_ and port _p'_.

. Let _T_ be the topology constructed from _I_ and _C_,
after applying
<<Definitions_Topology-Definitions_Semantics_Automatic-Numbering-of-Array-Indices,
automatic numbering of array indices>>.

. For each import specifier _S_ appearing in _D_, do the following:

.. Let _T'_ be the topology referred to in _S_.

.. Let _T''_ be the result of 
<<Definitions_Topology-Import-Specifiers,importing>>
_T'_ into _T_.

.. Let _T_ = _T''_.

===== Automatic Numbering of Array Indices

*General numbering:* FPP automatically numbers the array indices appearing in 
the <<Definitions_Connection-Graph-Definitions,connections>>
of a topology _T_ as follows.

. For each position _P_ (output or input) in each connection _C_, do the following:

.. If _P_ has an array index expression _e_ in the FPP source, then
<<Evaluation,evaluate>> _e_,
<<Type-Checking_Type-Conversion,convert>> the result to a value _n_ of type 
_Integer_, and assign the index _n_ at that position.
Check that _n_ is in bounds for the
<<Definitions_Port-Definitions,port>> being indexed.

.. Otherwise assign the smallest available index at position _P_.
An index is available if (1) it is in bounds for the 
<<Definitions_Port-Definitions,port>> being indexed; and (2)
it is not already assigned to the same port in the topology.
If no index is available, throw an error.

. Check that in _C_ there is no pair of connections _c1_ and _c2_
with the same output port instance _i_ and the same port array index at _i_.
For example, the following pair of connections is not allowed:
+
[source,fpp]
----
a.p[0] -> b.p
a.p[0] -> c.p
----

Note that in step 1(a), the order of traversal of the connections is
not specified in the FPP source.

*Special numbering:* Particular translation strategies may apply
special numbering passes. For example:

* There may be a numbering pass to ensure
that the indices of the command registration connections coming into the 
command dispatcher match the indices of the command connections going out
of the command dispatcher.

* There may be a numbering pass to ensure
that the indices of the command connections going out of the sequencer
match the indices of the command response connections coming into the 
sequencer.

==== Examples

*Example 1.*

[source,fpp]
----
@ Command and data handling topology
topology CDH {

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance commandDispatcher
  instance commandSequencer
  instance engineeringRateGroup
  instance engineeringTelemetryLogger
  instance engineeringTelemetryConverter
  instance engineeringTelemetrySplitter
  instance eventLogger
  instance rateGroupDriver
  instance telemetryDatabase
  instance timeSource

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connections
  # ----------------------------------------------------------------------

  connections CommandRegistration {
    commandDispatcher.cmdRegOut -> commandDispatcher.cmdRegIn
    commandSequencer.cmdRegOut -> commandDispatcher.cmdRegIn
    engineeringTelemetryLogger.cmdRegOut -> commandDispatcher.cmdRegIn
    eventLogger.cmdRegOut -> commandDispatcher.cmdRegIn
    telemetryDatabase.cmdRegOut -> commandDispatcher.cmdRegIn
    timeSource.cmdRegOut -> commandDispatcher.cmdRegIn
  }

  connections CommandResponses {
    commandDispatcher.cmdResponseInOut -> commandSequencer.cmdResponseIn
    commandDispatcher.cmdResponseOut -> commandDispatcher.cmdResponseIn
    commandSequencer.cmdResponseOut -> commandDispatcher.cmdResponseIn
    engineeringTelemetryLogger.cmdResponseOut -> commandDispatcher.cmdResponseIn
    eventLogger.cmdResponseOut -> commandDispatcher.cmdResponseIn
    telemetryDatabase.cmdResponseOut -> commandDispatcher.cmdResponseIn
    timeSource.cmdResponseOut -> commandDispatcher.cmdResponseIn
  }

  connections CommandSequences {
    commandSequencer.comCmdOut -> commandDispatcher.comCmdIn
  }

  connections Commands {
    commandDispatcher.cmdOut -> commandDispatcher.cmdIn
    commandDispatcher.cmdOut -> commandSequencer.cmdIn
    commandDispatcher.cmdOut -> engineeringTelemetryLogger.cmdIn
    commandDispatcher.cmdOut -> eventLogger.cmdIn
    commandDispatcher.cmdOut -> telemetryDatabase.cmdIn
    commandDispatcher.cmdOut -> timeSource.cmdIn
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    commandDispatcher.tlmOut -> engineeringTelemetrySplitter.tlmIn
    commandSequencer.tlmOut -> telemetryDatabase.tlmIn
    engineeringRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    engineeringTelmetryConverter.comTlmOut -> engineeringTelemetryLogger.comTlmIn
    engineeringTelemetrySplitter.tlmOut -> engineeringTelemetryConverter.tlmIn
    engineeringTelemetrySplitter.tlmOut -> telemetryDatabase.tlmIn
  }

  connections Events {
    commandDispatcher.eventOut -> eventLogger.eventIn
    commandSequencer.eventOut -> eventLogger.eventIn
    engineeringRateGroup.eventOut -> eventLogger.eventIn
    engineeringTelemetryLogger.eventOut -> eventLogger.eventIn
    eventLogger.eventOut -> eventLogger.eventIn
    telemetryDatabase.eventOut -> eventLogger.eventIn
  }

  connections RateGroups {
    engineeringRateGroup.schedOut -> commandSequencer.schedIn
    engineeringRateGroup.schedOut -> telemetryDatabase.schedIn
    rateGroupDriver.cycleOut -> engineeringRateGroup.cycleIn
  }

  connections Time {
    commandDispatcher.timeGetOut -> timeSource.timeGetIn
    engineeringRateGroup.timeGetOut -> timeSource.timeGetIn
    engineeringTelemetryLogger.timeGetOut -> timeSource.timeGetIn
    eventLogger.timeGetOut -> timeSource.timeGetIn
    sequencer.timeGetOut -> timeSource.timeGetIn
    socketGroundInterface.timeGetOut -> timeSource.timeGetIn
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

}
----

*Example 2.*

[source,fpp]
----
@ Attitude control topology
topology AttitudeControl {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import CDH

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance acsRateGroup
  instance attitudeControl
  ...

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connections
  # ----------------------------------------------------------------------

  connections AttitudeTelemetry {
    ...
  }

  connections CommandRegistration {
    attitudeControl.cmdRegOut -> commandDispatcher.cmdRegIn
    ...
  }

  connections CommandResponses {
    attitudeControl.cmdResponseOut -> commandDispatcher.cmdResponseIn
    ...
  }

  connections Commands {
    commandDispatcher.cmdOut -> attitudeControl.cmdIn
    ...
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    acsRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    ...
  }

  connections Events {
    attitudeControl.eventOut -> eventLogger.eventIn
    acsRateGroup.eventOut -> eventLogger.eventIn
    ...
  }

  connections RateGroups {
    acsRateGroup.schedOut -> attitudeControl.schedIn
  }

  connections Time {
    acsRateGroup.timeGetOut -> timeSource.timeGetIn
    attitudeControl.timeGetOut -> timeSource.timeGetIn
    ...
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

}
----

*Example 3.*

[source,fpp]
----
@ Release topology
topology Release {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import AttitudeControl
  import CDH
  import Communication
  ...

}
----
