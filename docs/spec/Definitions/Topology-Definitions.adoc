=== Topology Definitions

A *topology definition* defines an F Prime topology,
that is, a set of component instances and the connections
between their ports.
The connections are divided into named *connection graphs*.
The different graphs capture different aspects of FSW
function, such as commanding and telemetry.

One topology can be imported into another one.
The connections are merged graph by graph.

==== Syntax

`topology` 
<<Lexical-Elements_Identifiers,_identifier_>>
`{` _topology-member-sequence_ `}`

_topology-member-sequence_ is an
<<Element-Sequences,element sequence>> in 
which each element is a *topology member*,
and the terminating punctuation is a semicolon.
A topology member is one of the following:

* A <<Specifiers_Component-Instance-Specifiers,component 
instance specifier>>

* A <<Specifiers_Connection-Graph-Specifiers,connection graph specifier>>

* A <<Specifiers_Topology-Import-Specifiers,topology import specifier>>

* An <<Specifiers_Include-Specifiers,include specifier>>

* An <<Specifiers_Unused-Port-Specifiers,unused port specifier>>

==== Semantics

A topology definition _D_ must be resolvable to a topology _T_,
according to the following algorithm:

. Resolve _D_ to a
<<Definitions_Topology-Definitions_Semantics_Resolving-to-a-Partially-Numbered-Topology,
partially numbered topology>> _T'_.

. Apply 
<<Definitions_Topology-Definitions_Semantics_Automatic-Numbering-of-Ports,
automatic numbering of ports>>
to _T'_.

. <<Definitions_Topology-Definitions_Semantics_Checking-for-Unconnected-Ports,
Check for unconnected ports>> in _T'_.

===== Resolving to a Partially Numbered Topology

A *partially numbered topology* is a topology in which port number
assignments may or may not exist for each connection.
A port number assignment exists if
it is specified in the model source.

. For each endpoint _E_ (output or input) in each connection _C_
appearing in _D_,
if _E_ has a port number  expression _e_ in the FPP source, then
<<Evaluation,evaluate>> _e_,
<<Type-Checking_Type-Conversion,convert>> the result to a value _n_ of type 
_Integer_, and assign the port number _n_ at that position.
Check that _n_ is in bounds for the port instance being numbered.

. Let _T_ be the topology given by all
<<Specifiers_Component-Instance-Specifiers,instances>> (both public and
private) appearing in _D_ and all
<<Specifiers_Connection-Graph-Specifiers,direct connection graphs>> appearing in
_D_, after merging each set of connection graphs with the same name into
a single graph.
For example, the two connection graphs
+
[source,fpp]
----
connections C { a.b -> c.d }
----
+
and
+
[source,fpp]
----
connections C { e.f -> g.h }
----
+
are treated as the single graph
+
[source,fpp]
----
connections C { a.b -> c.d, e.f -> g.h }
----

. For each import specifier _S_ appearing in _D_, do the following:

.. Check that _S_ has not already been imported into _T_.

.. Let _T'_ be the topology given by resolving the topology definition named in
_S_ to a partially numbered topology.

.. Let _T''_ be the result of 
<<Specifiers_Topology-Import-Specifiers,importing>>
_T'_ into _T_.

.. Let _T_ = _T''_.

. Resolve 
<<Specifiers_Connection-Graph-Specifiers,pattern graph specifiers>>,
adding connections to _T_.
Add only connections that are not already present in _T_.
For example, if a command pattern indicates a command
registration connection between two ports, and there is already
a command registration connection between those ports, then
do not add the connection.

===== Automatic Numbering of Ports

FPP automatically assigns port numbers as follows.

*Check output port numbers:*
At each output port _p_ of each component instance _I_, check that

. The number of connections at each output port is in bounds for the 
size of _p_.

. There is no pair of connections stem:[c_1] and stem:[c_2]
at the same port number of _I_ `.` _p_.
For example, the following pair of connections is not allowed:
+
[source,fpp]
----
a.p[0] -> b.p
a.p[0] -> c.p
----

*Apply matched numbering:*
Assign matching numbers to matched pairs of ports.
For each instance _I_ in the topology with component type
_C_, for each
<<Specifiers_Port-Matching-Specifiers,port matching specifier>>
`match` stem:[p_1] `with` stem:[p_2] appearing in the definition of _C_:
 
.  For each connection stem:[c_1] with an endpoint at _I_ `.` stem:[p_1]:
 
.. Let _I'_ be the component instance at the other endpoint
of stem:[c_1].
 
.. Check that there is one and only one connection
stem:[c_2] from _I'_ to _I_ `.` stem:[p_2].

. Check that the connections stem:[c_2] computed in the previous
step are all the connections at _I_ `.` stem:[p_2].
 
. For each pair stem:[(c_1,c_2)] that has both port numbers assigned,
check that the port numbers match.
For each pair stem:[(c_1,c_2)] that has exactly one port number assigned,
assign the other one to match.
 
. For each pair stem:[(c_1,c_2)] that does not yet have assigned
port numbers, find the lowest available port number
and assign it at _I_ `.` stem:[p_1] and _I_ `.` stem:[p_2].
A port number is available if (a) it is in bounds for the 
port instance being numbered; and (b)
it is not already assigned to the same port instance
in the topology.

Note that in the last step

* The two ports stem:[p_1] and _I_ `.` stem:[p_2].
have the same array size and
the same port numbers assigned so far, so the lowest
available port number is the same for both.

* Because the order of traversing the ports is
not specified in the FPP source, multiple numberings are
possible.
The translator picks a legal one.

*Apply general numbering:* 
Fill in any remaining port numbers.

. For each output endpoint _P_ in each connection _C_,
if no port number is already assigned, then assign the lowest available port 
number at position _P_.


. For each input endpoint _P_ in each connection _C_, if no port number is 
already assigned, then assign the port number zero.

See Example 4 below.

===== Checking for Unconnected Ports

After resolving a topology definition _D_ to a numbered topology _T_,
check for unused ports in _T_ as follows:

. For each instance _I_ appearing in _T_, for each port _P_ of _I_,
if (a) there is no connection to or from any index of _P_ and (b)
_P_ does not appear in any 
<<Specifiers_Unused-Port-Specifiers,unused port specifier>> of _D_,
then issue a warning.

==== Examples

*Example 1.*

[source,fpp]
----
@ Command and data handling topology
topology CDH {

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance commandDispatcher
  instance commandSequencer
  instance engineeringRateGroup
  instance engineeringTelemetryLogger
  instance engineeringTelemetryConverter
  instance engineeringTelemetrySplitter
  instance eventLogger
  instance rateGroupDriver
  instance telemetryDatabase
  instance timeSource

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  private instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connection patterns
  # ----------------------------------------------------------------------

  command connections instance commandDispatcher
  event connections instance eventLogger
  time connections instance timeSource

  # ---------------------------------------------------------------------- 
  # Connection graphs
  # ---------------------------------------------------------------------- 

  connections CommandSequences {
    commandSequencer.comCmdOut -> commandDispatcher.comCmdIn
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    commandDispatcher.tlmOut -> engineeringTelemetrySplitter.tlmIn
    commandSequencer.tlmOut -> telemetryDatabase.tlmIn
    engineeringRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    engineeringTelmetryConverter.comTlmOut -> engineeringTelemetryLogger.comTlmIn
    engineeringTelemetrySplitter.tlmOut -> engineeringTelemetryConverter.tlmIn
    engineeringTelemetrySplitter.tlmOut -> telemetryDatabase.tlmIn
  }

  connections RateGroups {
    engineeringRateGroup.schedOut -> commandSequencer.schedIn
    engineeringRateGroup.schedOut -> telemetryDatabase.schedIn
    rateGroupDriver.cycleOut -> engineeringRateGroup.cycleIn
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

  # ----------------------------------------------------------------------
  # Unused ports 
  # ----------------------------------------------------------------------

  unused {
    commandDispatcher.pingIn
    commandDispatcher.pingOut
    commandSequencer.pingIn
    commandSequencer.pingOut
    engineeringRateGroup.pingIn
    engineeringRateGroup.pingOut
    engineeringTelemetryLogger.bufferSendIn
    engineeringTelemetryLogger.bufferSendOut
    engineeringTelemetryLogger.pingIn
    engineeringTelemetryLogger.pingOut
    eventLogger.pingIn
    eventLogger.pingOut
    socketGroundInterface.fileDownlinkBufferSendIn
    socketGroundInterface.fileDownlinkBufferSendOut
    socketGroundInterface.fileUplinkBufferGet
    socketGroundInterface.fileUplinkBufferSendOut
    telemetryDatabase.comTlmOut
    telemetryDatabase.pingIn
    telemetryDatabase.pingOut
    telemetryDatabase.schedIn
    telemetryDatabase.tlmGetIn
  }

}
----

*Example 2.*

[source,fpp]
----
@ Attitude control topology
topology AttitudeControl {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import CDH

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance acsRateGroup
  instance attitudeControl
  ...

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connection patterns
  # ----------------------------------------------------------------------

  command connections instance commandDispatcher
  event connections instance eventLogger
  time connections instance timeSource


  # ----------------------------------------------------------------------
  # Connection graphs
  # ----------------------------------------------------------------------

  connections AttitudeTelemetry {
    ...
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    acsRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    ...
  }

  connections RateGroups {
    acsRateGroup.schedOut -> attitudeControl.schedIn
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

}
----

*Example 3.*

[source,fpp]
----
@ Release topology
topology Release {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import AttitudeControl
  import CDH
  import Communication
  ...

}
----

*Example 4.*

Here is one topology that can result from automatic numbering of ports
applied to topology `B` in the
<<Specifiers_Topology-Import-Specifiers_Example,example for topology import
specifiers>>:

[source,fpp]
----
topology B {

  instance a
  instance c
  instance d
  instance e
  instance f 

  connections C1 {
    a.p1[0] -> c.p[0]
    a.p1[1] -> d.p[0]
  }

  connections C2 {
    a.p2[0] -> e.p[0]
  }

  connections C3 {
    a.p3[0] -> f.p[0]
  }

}
----

In general, where there are multiple connections to a single port array, the 
exact assignment of indices is not specified by the automatic numbering 
algorithm.
Another valid topology would reverse the assignment of 0 and 1 to `a.p1 
pass:[->] c.p` and `a.p1 pass:[->] d.p`.

