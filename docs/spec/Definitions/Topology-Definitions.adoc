=== Topology Definitions

A *topology definition* defines an F Prime topology,
that is, a set of component instances and the connections
between their ports.
The connections are divided into named *connection graphs*.
The different graphs capture different aspects of FSW
function, such as commanding and telemetry.

One topology can be imported into another one.
The connections are merged graph by graph.

==== Syntax

`topology` 
<<Lexical-Elements_Identifiers,_identifier_>>
`{` _topology-member-sequence_ `}`

_topology-member-sequence_ is an
<<Element-Sequences,element sequence>> in 
which each element is a *topology member*,
and the terminating punctuation is a semicolon.
A topology member is one of the following:

* A <<Definitions_Topology-Import-Specifiers,topology import specifier>>

* A <<Definitions_Component-Instance-Specifiers,component 
instance specifier>>

* A <<Definitions_Connection-Graph-Definitions,connection graph definition>>

==== Semantics

A topology defintion _D_ must be resolvable to a topology _T_,
according to the following algorithm:

. Resolve _D_ to an
<<Definitions_Topology-Definitions_Semantics_Resolving-to-an-Unnumbered-Topology,unnumbered
topology>> _T'_.

. Apply 
<<Definitions_Topology-Definitions_Semantics_Automatic-Numbering-of-Array-Indices,
automatic numbering of array indices>>
to _T'_.

===== Resolving to an Unnumbered Topology

An *unnumbered topology* is a topology in which port array index expressions
may or may not be present, and if they are present their meaning is ignored.

. Let _T_ be the topology given by all
<<Definitions_Component-Instance-Specifiers,instances>> (both public and
private) appearing in _D_ and all
<<Definitions_Connection-Graph-Definitions,connection graphs>> appearing in
_D_.

. For each import specifier _S_ appearing in _D_, do the following:

.. Let _T'_ be the topology given by resolving the topology definition named in
_S_ to an unnumbered topology.

.. Let _T''_ be the result of 
<<Definitions_Topology-Import-Specifiers,importing>>
_T'_ into _T_.

.. Let _T_ = _T''_.

===== Automatic Numbering of Array Indices

*General numbering:* FPP automatically numbers the array indices appearing in 
the <<Definitions_Connection-Graph-Definitions,connections>>
of a topology _T_ as follows.

. For each position _P_ (output or input) in each connection _C_, 
if _P_ has an array index expression _e_ in the FPP source, then
<<Evaluation,evaluate>> _e_,
<<Type-Checking_Type-Conversion,convert>> the result to a value _n_ of type 
_Integer_, and assign the index _n_ at that position.
Check that _n_ is in bounds for the
<<Definitions_Port-Definitions,port>> being indexed.

. Check that in _C_ there is no pair of connections _c1_ and _c2_
with the same output port instance _i_ and the same port array index at _i_.
For example, the following pair of connections is not allowed:
+
[source,fpp]
----
a.p[0] -> b.p
a.p[0] -> c.p
----

. For each output position _P_ in each connection _C_,
if no index is already assigned, then assign the smallest available index at 
position _P_.
An index is available if (1) it is in bounds for the 
<<Definitions_Port-Definitions,port>> being indexed; and (2)
it is not already assigned to the same port in the topology.
If no index is available, throw an error.

. For each input position _P_ in each connection _C_, 
if no index is already assinged, then assign the index zero.

Note that in step 1(a), the order of traversal of the connections is
not specified in the FPP source.

*Special numbering:* Particular translation strategies may apply
special numbering passes. For example:

* There may be a numbering pass to ensure
that the indices of the command registration connections coming into the 
command dispatcher match the indices of the command connections going out
of the command dispatcher.

* There may be a numbering pass to ensure
that the indices of the command connections going out of the sequencer
match the indices of the command response connections coming into the 
sequencer.

==== Examples

*Example 1.*

[source,fpp]
----
@ Command and data handling topology
topology CDH {

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance commandDispatcher
  instance commandSequencer
  instance engineeringRateGroup
  instance engineeringTelemetryLogger
  instance engineeringTelemetryConverter
  instance engineeringTelemetrySplitter
  instance eventLogger
  instance rateGroupDriver
  instance telemetryDatabase
  instance timeSource

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connections
  # ----------------------------------------------------------------------

  connections CommandRegistration {
    commandDispatcher.cmdRegOut -> commandDispatcher.cmdRegIn
    commandSequencer.cmdRegOut -> commandDispatcher.cmdRegIn
    engineeringTelemetryLogger.cmdRegOut -> commandDispatcher.cmdRegIn
    eventLogger.cmdRegOut -> commandDispatcher.cmdRegIn
    telemetryDatabase.cmdRegOut -> commandDispatcher.cmdRegIn
    timeSource.cmdRegOut -> commandDispatcher.cmdRegIn
  }

  connections CommandResponses {
    commandDispatcher.cmdResponseInOut -> commandSequencer.cmdResponseIn
    commandDispatcher.cmdResponseOut -> commandDispatcher.cmdResponseIn
    commandSequencer.cmdResponseOut -> commandDispatcher.cmdResponseIn
    engineeringTelemetryLogger.cmdResponseOut -> commandDispatcher.cmdResponseIn
    eventLogger.cmdResponseOut -> commandDispatcher.cmdResponseIn
    telemetryDatabase.cmdResponseOut -> commandDispatcher.cmdResponseIn
    timeSource.cmdResponseOut -> commandDispatcher.cmdResponseIn
  }

  connections CommandSequences {
    commandSequencer.comCmdOut -> commandDispatcher.comCmdIn
  }

  connections Commands {
    commandDispatcher.cmdOut -> commandDispatcher.cmdIn
    commandDispatcher.cmdOut -> commandSequencer.cmdIn
    commandDispatcher.cmdOut -> engineeringTelemetryLogger.cmdIn
    commandDispatcher.cmdOut -> eventLogger.cmdIn
    commandDispatcher.cmdOut -> telemetryDatabase.cmdIn
    commandDispatcher.cmdOut -> timeSource.cmdIn
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    commandDispatcher.tlmOut -> engineeringTelemetrySplitter.tlmIn
    commandSequencer.tlmOut -> telemetryDatabase.tlmIn
    engineeringRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    engineeringTelmetryConverter.comTlmOut -> engineeringTelemetryLogger.comTlmIn
    engineeringTelemetrySplitter.tlmOut -> engineeringTelemetryConverter.tlmIn
    engineeringTelemetrySplitter.tlmOut -> telemetryDatabase.tlmIn
  }

  connections Events {
    commandDispatcher.eventOut -> eventLogger.eventIn
    commandSequencer.eventOut -> eventLogger.eventIn
    engineeringRateGroup.eventOut -> eventLogger.eventIn
    engineeringTelemetryLogger.eventOut -> eventLogger.eventIn
    eventLogger.eventOut -> eventLogger.eventIn
    telemetryDatabase.eventOut -> eventLogger.eventIn
  }

  connections RateGroups {
    engineeringRateGroup.schedOut -> commandSequencer.schedIn
    engineeringRateGroup.schedOut -> telemetryDatabase.schedIn
    rateGroupDriver.cycleOut -> engineeringRateGroup.cycleIn
  }

  connections Time {
    commandDispatcher.timeGetOut -> timeSource.timeGetIn
    engineeringRateGroup.timeGetOut -> timeSource.timeGetIn
    engineeringTelemetryLogger.timeGetOut -> timeSource.timeGetIn
    eventLogger.timeGetOut -> timeSource.timeGetIn
    sequencer.timeGetOut -> timeSource.timeGetIn
    socketGroundInterface.timeGetOut -> timeSource.timeGetIn
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

}
----

*Example 2.*

[source,fpp]
----
@ Attitude control topology
topology AttitudeControl {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import CDH

  # ----------------------------------------------------------------------
  # Public instances 
  # ----------------------------------------------------------------------

  instance acsRateGroup
  instance attitudeControl
  ...

  # ----------------------------------------------------------------------
  # Private instances 
  # ----------------------------------------------------------------------

  instance socketGroundInterface

  # ----------------------------------------------------------------------
  # Connections
  # ----------------------------------------------------------------------

  connections AttitudeTelemetry {
    ...
  }

  connections CommandRegistration {
    attitudeControl.cmdRegOut -> commandDispatcher.cmdRegIn
    ...
  }

  connections CommandResponses {
    attitudeControl.cmdResponseOut -> commandDispatcher.cmdResponseIn
    ...
  }

  connections Commands {
    commandDispatcher.cmdOut -> attitudeControl.cmdIn
    ...
  }

  connections Downlink {
    eventLogger.comOut -> socketGroundInterface.comEventIn
    telemetryDatabase.comOut -> socketGroundInterface.comTlmIn
  }

  connections EngineeringTelemetry {
    acsRateGroup.tlmOut -> engineeringTelemetrySplitter.tlmIn
    ...
  }

  connections Events {
    attitudeControl.eventOut -> eventLogger.eventIn
    acsRateGroup.eventOut -> eventLogger.eventIn
    ...
  }

  connections RateGroups {
    acsRateGroup.schedOut -> attitudeControl.schedIn
  }

  connections Time {
    acsRateGroup.timeGetOut -> timeSource.timeGetIn
    attitudeControl.timeGetOut -> timeSource.timeGetIn
    ...
  }

  connections Uplink {
    socketGroundInterface.comCmdOut -> commandDispatcher.comCmdIn
  }

}
----

*Example 3.*

[source,fpp]
----
@ Release topology
topology Release {

  # ----------------------------------------------------------------------
  # Imported topologies 
  # ----------------------------------------------------------------------

  import AttitudeControl
  import CDH
  import Communication
  ...

}
----

*Example 4.*

Here is one topology that can result from automatic numbering of array indices
applied to topology `B` in the
<<Definitions_Topology-Import-Specifiers_Example,example for topology import
specifiers>>:

[source,fpp]
----
topology B {

  instance a
  instance c
  instance d
  instance e
  instance f 

  connections C1 {
    a.p1[0] -> c.p[0]
    a.p1[1] -> d.p[0]
  }

  connections C2 {
    a.p2[0] -> e.p[0]
  }

  connections C3 {
    a.p3[0] -> f.p[0]
  }

}
----

In general, where there are multiple connections to a single port array, the 
exact assignment of indices is not specified by the automatic numbering 
algorithm.
Another valid topology would reverse the assignment of 0 and 1 to `a.p1 
pass:[->] c.p` and `a.p1 pass:[->] d.p`.

