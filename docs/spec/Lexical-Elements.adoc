== Lexical Elements

Before parsing an FPP model, the compiler converts the source
text into a list of **tokens**.
This process is called **lexing**.

A token is one of the following:

* A <<Lexical-Elements_Reserved-Words,reserved word>>.

* A <<Lexical-Elements_Symbols,symbol>>.

* An <<Lexical-Elements_Identifiers,identifier>>.

* An <<Expressions_Integer-Literals,integer literal>>.

* A <<Expressions_Floating-Point-Literals,floating-point literal>>.

* A <<Expressions_Boolean-Literals,Boolean literal>>.

* A <<Expressions_String-Literals,string literal>>.

* A <<Lexical-Elements_Code-Strings,code string>>

* A <<Lexical-Elements_Newlines,newline token>>.

* A line of an <<Comments-and-Annotations_Annotations,annotation>>
beginning with `@` or `@<`.

=== Reserved Words

The following are reserved words in FPP.
They may not be used as identifiers.

[source,fpp]
----
F32
F64
I16
I32
I64
I8
U16
U32
U64
U8
active
activity
always
array
assert
async
at
base
block
bool
change
command
component
constant
default
diagnostic
drop
enum
event
false
fatal
format
get
guarded
high
id
include
init
input
instance
internal
locate
low
module
on
opcode
orange
output
param
passive
phase
port
priority
private
queued
recv
red
ref
reg
resp
save
serial
set
size
string
struct
sync
telemetry
text
throttle
time
topology
true
type
update
warning
yellow
----

=== Symbols

The following sequences of characters are symbol tokens in FPP:

[source,fpp]
----
(
)
,
-
->
.
:
;
=
[
\
]
{
}
----

=== Identifiers

An *identifier* is an unqualified name
consisting of one or more characters. The first character
must be a letter or an underscore. Characters after the first character
may be letters, digits, and underscores.

**Examples:**

----
Identifier
MultiPartIdentifier
_identifier_
identifier
identifier_
multiPartIdentifier
multi_part_identifier
----

=== Code Strings

A *code string* is a sequence of characters enclosed in triple double 
quotes `"""`
The characters must be printable ASCII characters, including newline.
A sequence of three double quotes is not allowed inside the string, except
that the sequene `\"""` represents three double quotes.
The first newline after the first `"""` (if it exists) is omitted
from the output string.

*Example:*

[source,fpp]
----
"""
// This is a code string
instance.create(0, 1);
"""
----

The output string consists of two lines, each followed by a newline.

=== Newlines

The NL character (ASCII code 0x0A), optionally preceded by a CR character 
(ASCII code 0x0D), is a token. Sequences of one or more newlines separate the 
elements of <<Element-Sequences,element sequences>>.

=== Comments

<<Comments-and-Annotations_Comments,Comments>> are ignored during lexing.

=== Whitespace and Non-Printable Characters

Apart from <<Lexical-Elements_Newlines,newlines>>, the lexer treats whitespace 
as follows:

* Space characters are ignored, except to separate tokens.

* No other whitespace or non-printable characters are allowed
outside of a comment or annotation.
In particular, the tab character may not appear
in an FPP model outside of a comment or annotation.

=== Explicit Line Continuations

The token `\`, when appearing before a newline, causes the newline to
be ignored. For example, this

[source,fpp]
----
constant a \
  = 1
----
is equivalent to this:

[source,fpp]
----
constant a = 1
----

Note that the `\` token is required in this case.
For example, the following is not syntactically correct:

[source,fpp]
----
constant a # Error
  = 1
----

The newline indicates the end of an element sequence, but
`constant a` is not a valid element sequence.

=== Automatic Line Continuations

The following symbols consume sequences of newlines that
follow them:

[source,fpp]
----
(
*
+
,
-
->
/
:
;
=
[
{
----

For example, the following code is legal:

[source,fpp]
----
module M {
  constant a = 0
}
----

It is equivalent to this code:

[source,fpp]
----
module M { constant a = 0 }
----

The newline after the `{` symbol is consumed by the symbol.
The newline after the constant definition is consumed
by the element sequence member.

The following code is also legal, because the newline is
consumed by the `=` symbol:

[source,fpp]
----
constant a =
  0
----

Similarly, the following code is legal, because the newline
is consumed by the `+` symbol:

[source,fpp]
----
constant a = 1 + 
  2
----
