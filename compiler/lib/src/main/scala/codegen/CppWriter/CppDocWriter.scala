package fpp.compiler.codegen

import java.time.Year

/** A C++ doc writer */
trait CppDocWriter extends CppDocVisitor with LineUtils {

  case class Input(
    /** The hpp file */
    hppFile: CppDoc.HppFile,
    /** The cpp file name */
    cppFileName: String,
    /** The list of enclosing class names, backwards. A class name may include :: */
    classNameList: List[String] = Nil,
  ) {

    def getEnclosingClassQualified = classNameList.reverse.mkString("::")
 
    def getEnclosingClassUnqualified = classNameList.head.split("::").reverse.head

  }

  def default(in: Input) = Output()

  def visitCppDoc(cppDoc: CppDoc): Output

  case class Output(
    /** The lines of the file */
    outputLines: List[Line] = Nil,
  ) {

    def ++(output: Output) = Output(outputLines ++ output.outputLines)

    def indentIn(increment: Int = indentIncrement) = Output(outputLines.map(_.indentIn(increment)))

  }

  object Output {

    def cpp(lines: List[Line]) = Output(lines)

    def hpp(lines: List[Line]) = Output(lines)

  }

}

object CppDocWriter extends LineUtils {

  def accessTag(tag: String) = List(
    Line.blank,
    line(s"$tag:").indentOut(2)
  )

  def bannerComment(comment: String) = {
    def banner =
      line("// ----------------------------------------------------------------------")
    (Line.blank :: banner :: commentBody(comment)) :+ banner
  }

  def comment(comment: String) = Line.blank :: commentBody(comment)

  def doxygenCommentOpt(commentOpt: Option[String]) = commentOpt match {
    case Some(comment) => doxygenComment(comment)
    case None => Line.blank :: Nil
  }
    
  def doxygenComment(comment: String) = 
    Line.blank ::lines(comment).map(Line.join(" ")(line("//!"))_)
    
  def commentBody(comment: String) = lines(comment).map(Line.join(" ")(line("//"))_)

  def cppParamString(p: CppDoc.Function.Param) = s"${p.t.hppType} ${p.name}"

  def writeCppParam(p: CppDoc.Function.Param) = line(cppParamString(p))

  def writeCppParamComma(p: CppDoc.Function.Param) = line(cppParamStringComma(p))

  def hppParamString(p: CppDoc.Function.Param) = {
    val s1 = CppDocWriter.cppParamString(p)
    val s2 = addParamComment(s1, p.comment)
    s2
  }

  def addParamComment(s: String, commentOpt: Option[String]) = commentOpt match {
    case Some(comment) => s"$s //!< ${"\n".r.replaceAllIn(comment, " ")}"
    case None => s
  }

  def closeIncludeGuard = lines(
    """|
       |#endif"""
  )

  def cppParamStringComma(p: CppDoc.Function.Param) = s"${p.t.hppType} ${p.name},"

  def hppParamStringComma(p: CppDoc.Function.Param) = {
    val s1 = cppParamStringComma(p)
    val s2 = addParamComment(s1, p.comment)
    s2
  }

  def leftAlignDirective(line: Line) =
    if (line.string.startsWith("#")) Line(line.string) else line

  def openIncludeGuard(guard: String): List[Line] = {
    lines(
      s"""|
          |#ifndef $guard
          |#define $guard"""
    )
  }

  def writeBanner(title: String) = lines(
    s"""|// ====================================================================== 
        |// \\title  $title
        |// \\author Generated by fpp-to-cpp
        |//
        |// \\copyright
        |// Copyright (C) ${Year.now.getValue} California Institute of Technology.
        |// ALL RIGHTS RESERVED.  United States Government Sponsorship
        |// acknowledged. Any commercial use must be negotiated with the Office
        |// of Technology Transfer at the California Institute of Technology.
        |// 
        |// This software may be subject to U.S. export control laws and
        |// regulations.  By accepting this document, the user agrees to comply
        |// with all U.S. export laws and regulations.  User has the
        |// responsibility to obtain export licenses, or other export authority
        |// as may be required before exporting such information to foreign
        |// countries or providing access to foreign persons.
        |// ======================================================================"""
  )

  def writeCppParams(prefix: String, params: List[CppDoc.Function.Param]) = {
    if (params.length == 0) lines(s"$prefix()")
    else if (params.length == 1)
      lines(s"$prefix(" ++ CppDocWriter.cppParamString(params.head) ++ ")")
    else {
      val head :: tail = params.reverse
      val paramLines = (writeCppParam(head) :: tail.map(writeCppParamComma(_))).reverse
      line(s"$prefix(") :: (paramLines.map(_.indentIn(2 * indentIncrement)) :+ line(")"))
    }
  }

  def writeFunctionBody(body: List[Line]) = {
    val bodyLines = body.length match {
      case 0 => Line.blank :: Nil
      case _ => body.map(indentIn(_))
    }
    (line("{") :: bodyLines) :+ line("}")
  }

  def writeHppParam(p: CppDoc.Function.Param) = line(hppParamString(p))

  def writeHppParamComma(p: CppDoc.Function.Param) = line(hppParamStringComma(p))

  def writeHppParams(prefix: String, params: List[CppDoc.Function.Param]) = {
    if (params.length == 0) lines(s"$prefix()")
    else if (params.length == 1 && params.head.comment.isEmpty)
      lines(s"$prefix(" ++ hppParamString(params.head) ++ ")")
    else {
      val head :: tail = params.reverse
      val paramLines = (writeHppParam(head) :: tail.map(writeHppParamComma(_))).reverse
      line(s"$prefix(") :: (paramLines.map(_.indentIn(2 * indentIncrement)) :+ line(")"))
    }
  }

}
