// ======================================================================
// \title  ActiveSerialTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ActiveSerial component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "ActiveSerialTesterBase.hpp"

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  init(NATIVE_INT_TYPE instance)
{
  this->m_param_ParamU32_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamF64_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamString_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamEnum_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamArray_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamStruct_valid = Fw::ParamValid::UNINIT;

  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port cmdRegOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_cmdRegOut());
    port++
  ) {
    this->m_from_cmdRegOut[port].init();
    this->m_from_cmdRegOut[port].addCallComp(
      this,
      from_cmdRegOut_static
    );
    this->m_from_cmdRegOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_cmdRegOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_cmdRegOut[port].setObjName(portName);
#endif
  }

  // Connect input port cmdResponseOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_cmdResponseOut());
    port++
  ) {
    this->m_from_cmdResponseOut[port].init();
    this->m_from_cmdResponseOut[port].addCallComp(
      this,
      from_cmdResponseOut_static
    );
    this->m_from_cmdResponseOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_cmdResponseOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_cmdResponseOut[port].setObjName(portName);
#endif
  }

  // Connect input port eventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_eventOut());
    port++
  ) {
    this->m_from_eventOut[port].init();
    this->m_from_eventOut[port].addCallComp(
      this,
      from_eventOut_static
    );
    this->m_from_eventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_eventOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_eventOut[port].setObjName(portName);
#endif
  }

  // Connect input port prmGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmGetOut());
    port++
  ) {
    this->m_from_prmGetOut[port].init();
    this->m_from_prmGetOut[port].addCallComp(
      this,
      from_prmGetOut_static
    );
    this->m_from_prmGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmGetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmGetOut[port].setObjName(portName);
#endif
  }

  // Connect input port prmSetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_prmSetOut());
    port++
  ) {
    this->m_from_prmSetOut[port].init();
    this->m_from_prmSetOut[port].addCallComp(
      this,
      from_prmSetOut_static
    );
    this->m_from_prmSetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_prmSetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_prmSetOut[port].setObjName(portName);
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect input port textEventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_textEventOut());
    port++
  ) {
    this->m_from_textEventOut[port].init();
    this->m_from_textEventOut[port].addCallComp(
      this,
      from_textEventOut_static
    );
    this->m_from_textEventOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_textEventOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_textEventOut[port].setObjName(portName);
#endif
  }
#endif

  // Connect input port timeGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_timeGetOut());
    port++
  ) {
    this->m_from_timeGetOut[port].init();
    this->m_from_timeGetOut[port].addCallComp(
      this,
      from_timeGetOut_static
    );
    this->m_from_timeGetOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_timeGetOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_timeGetOut[port].setObjName(portName);
#endif
  }

  // Connect input port tlmOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_tlmOut());
    port++
  ) {
    this->m_from_tlmOut[port].init();
    this->m_from_tlmOut[port].addCallComp(
      this,
      from_tlmOut_static
    );
    this->m_from_tlmOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_tlmOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_tlmOut[port].setObjName(portName);
#endif
  }

  // Connect input port typedOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_typedOut());
    port++
  ) {
    this->m_from_typedOut[port].init();
    this->m_from_typedOut[port].addCallComp(
      this,
      from_typedOut_static
    );
    this->m_from_typedOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_typedOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_typedOut[port].setObjName(portName);
#endif
  }

  // Connect input port typedReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_typedReturnOut());
    port++
  ) {
    this->m_from_typedReturnOut[port].init();
    this->m_from_typedReturnOut[port].addCallComp(
      this,
      from_typedReturnOut_static
    );
    this->m_from_typedReturnOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_typedReturnOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_typedReturnOut[port].setObjName(portName);
#endif
  }

  // Connect input port serialOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_from_serialOut());
    port++
  ) {
    this->m_from_serialOut[port].init();
    this->m_from_serialOut[port].addCallComp(
      this,
      from_serialOut_static
    );
    this->m_from_serialOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_from_serialOut[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_from_serialOut[port].setObjName(portName);
#endif
  }

  // Connect output port cmdIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_cmdIn());
    port++
  ) {
    this->m_to_cmdIn[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_cmdIn[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_cmdIn[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsAsync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsAsync());
    port++
  ) {
    this->m_to_noArgsAsync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsAsync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsAsync[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsGuarded());
    port++
  ) {
    this->m_to_noArgsGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsReturnGuarded());
    port++
  ) {
    this->m_to_noArgsReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsReturnSync());
    port++
  ) {
    this->m_to_noArgsReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port noArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_noArgsSync());
    port++
  ) {
    this->m_to_noArgsSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_noArgsSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_noArgsSync[port].setObjName(portName);
#endif
  }

  // Connect output port typedAsync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedAsync());
    port++
  ) {
    this->m_to_typedAsync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedAsync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedAsync[port].setObjName(portName);
#endif
  }

  // Connect output port typedAsyncAssert
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedAsyncAssert());
    port++
  ) {
    this->m_to_typedAsyncAssert[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedAsyncAssert[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedAsyncAssert[port].setObjName(portName);
#endif
  }

  // Connect output port typedAsyncBlockPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedAsyncBlockPriority());
    port++
  ) {
    this->m_to_typedAsyncBlockPriority[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedAsyncBlockPriority[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedAsyncBlockPriority[port].setObjName(portName);
#endif
  }

  // Connect output port typedAsyncDropPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedAsyncDropPriority());
    port++
  ) {
    this->m_to_typedAsyncDropPriority[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedAsyncDropPriority[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedAsyncDropPriority[port].setObjName(portName);
#endif
  }

  // Connect output port typedGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedGuarded());
    port++
  ) {
    this->m_to_typedGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port typedReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedReturnGuarded());
    port++
  ) {
    this->m_to_typedReturnGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedReturnGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedReturnGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port typedReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedReturnSync());
    port++
  ) {
    this->m_to_typedReturnSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedReturnSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedReturnSync[port].setObjName(portName);
#endif
  }

  // Connect output port typedSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_typedSync());
    port++
  ) {
    this->m_to_typedSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_typedSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_typedSync[port].setObjName(portName);
#endif
  }

  // Connect output port serialAsync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialAsync());
    port++
  ) {
    this->m_to_serialAsync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialAsync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialAsync[port].setObjName(portName);
#endif
  }

  // Connect output port serialAsyncAssert
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialAsyncAssert());
    port++
  ) {
    this->m_to_serialAsyncAssert[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialAsyncAssert[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialAsyncAssert[port].setObjName(portName);
#endif
  }

  // Connect output port serialAsyncBlockPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialAsyncBlockPriority());
    port++
  ) {
    this->m_to_serialAsyncBlockPriority[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialAsyncBlockPriority[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialAsyncBlockPriority[port].setObjName(portName);
#endif
  }

  // Connect output port serialAsyncDropPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialAsyncDropPriority());
    port++
  ) {
    this->m_to_serialAsyncDropPriority[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialAsyncDropPriority[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialAsyncDropPriority[port].setObjName(portName);
#endif
  }

  // Connect output port serialGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialGuarded());
    port++
  ) {
    this->m_to_serialGuarded[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialGuarded[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialGuarded[port].setObjName(portName);
#endif
  }

  // Connect output port serialSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_to_serialSync());
    port++
  ) {
    this->m_to_serialSync[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_to_serialSync[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_to_serialSync[port].setObjName(portName);
#endif
  }
}

// ----------------------------------------------------------------------
// Connectors for to ports
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  connect_to_cmdIn(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_cmdIn[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_noArgsAsync(
      NATIVE_INT_TYPE portNum,
      InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsAsync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_noArgsGuarded(
      NATIVE_INT_TYPE portNum,
      InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsGuarded[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_noArgsReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnGuarded[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_noArgsReturnSync(
      NATIVE_INT_TYPE portNum,
      InputNoArgsReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsReturnSync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_noArgsSync(
      NATIVE_INT_TYPE portNum,
      InputNoArgsPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_noArgsSync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedAsync(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedAsyncAssert(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncAssert[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedAsyncBlockPriority(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncBlockPriority[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedAsyncDropPriority(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedAsyncDropPriority[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedGuarded(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedGuarded[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedReturnGuarded(
      NATIVE_INT_TYPE portNum,
      InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnGuarded[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedReturnSync(
      NATIVE_INT_TYPE portNum,
      InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedReturnSync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_typedSync(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_typedSync[portNum].addCallPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialAsync(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialAsync[portNum].registerSerialPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialAsyncAssert(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialAsyncAssert[portNum].registerSerialPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialAsyncBlockPriority(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialAsyncBlockPriority[portNum].registerSerialPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialAsyncDropPriority(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialAsyncDropPriority[portNum].registerSerialPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialGuarded(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialGuarded[portNum].registerSerialPort(port);
}

void ActiveSerialTesterBase ::
  connect_to_serialSync(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_to_serialSync[portNum].registerSerialPort(port);
}

// ----------------------------------------------------------------------
// Getters for from ports
// ----------------------------------------------------------------------

Fw::InputCmdRegPort* ActiveSerialTesterBase ::
  get_from_cmdRegOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdRegOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdRegOut[portNum];
}

Fw::InputCmdResponsePort* ActiveSerialTesterBase ::
  get_from_cmdResponseOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_cmdResponseOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_cmdResponseOut[portNum];
}

Fw::InputLogPort* ActiveSerialTesterBase ::
  get_from_eventOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_eventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_eventOut[portNum];
}

Fw::InputPrmGetPort* ActiveSerialTesterBase ::
  get_from_prmGetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmGetOut[portNum];
}

Fw::InputPrmSetPort* ActiveSerialTesterBase ::
  get_from_prmSetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_prmSetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_prmSetOut[portNum];
}

#if FW_ENABLE_TEXT_LOGGING == 1

Fw::InputLogTextPort* ActiveSerialTesterBase ::
  get_from_textEventOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_textEventOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_textEventOut[portNum];
}

#endif

Fw::InputTimePort* ActiveSerialTesterBase ::
  get_from_timeGetOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_timeGetOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_timeGetOut[portNum];
}

Fw::InputTlmPort* ActiveSerialTesterBase ::
  get_from_tlmOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_tlmOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_tlmOut[portNum];
}

InputTypedPort* ActiveSerialTesterBase ::
  get_from_typedOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_typedOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedOut[portNum];
}

InputTypedReturnPort* ActiveSerialTesterBase ::
  get_from_typedReturnOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_typedReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_typedReturnOut[portNum];
}

Fw::InputSerializePort* ActiveSerialTesterBase ::
  get_from_serialOut(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_from_serialOut(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_from_serialOut[portNum];
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

ActiveSerialTesterBase ::
  ActiveSerialTesterBase(
      const char* const compName,
      U32 maxHistorySize
  ) :
    Fw::PassiveComponentBase(compName)
{
  // Initialize port histories
  this->fromPortHistory_typedOut = new History<FromPortEntry_typedOut>(maxHistorySize);
  this->fromPortHistory_typedReturnOut = new History<FromPortEntry_typedReturnOut>(maxHistorySize);

  // Initialize command history
  this->cmdResponseHistory = new History<CmdResponse>(maxHistorySize);

  // Initialize event histories
#if FW_ENABLE_TEXT_LOGGING
  this->textLogHistory = new History<TextLogEntry>(maxHistorySize);
#endif
  this->eventHistory_EventActivityLowThrottled = new History<EventEntry_EventActivityLowThrottled>(maxHistorySize);
  this->eventHistory_EventCommand = new History<EventEntry_EventCommand>(maxHistorySize);
  this->eventHistory_EventDiagnostic = new History<EventEntry_EventDiagnostic>(maxHistorySize);
  this->eventHistory_EventFatalThrottled = new History<EventEntry_EventFatalThrottled>(maxHistorySize);
  this->eventHistory_EventWarningHigh = new History<EventEntry_EventWarningHigh>(maxHistorySize);

  // Initialize telemetry histories
  this->tlmHistory_ChannelU32Format = new History<TlmEntry_ChannelU32Format>(maxHistorySize);
  this->tlmHistory_ChannelF32Format = new History<TlmEntry_ChannelF32Format>(maxHistorySize);
  this->tlmHistory_ChannelStringFormat = new History<TlmEntry_ChannelStringFormat>(maxHistorySize);
  this->tlmHistory_ChannelEnum = new History<TlmEntry_ChannelEnum>(maxHistorySize);
  this->tlmHistory_ChannelArrayFreq = new History<TlmEntry_ChannelArrayFreq>(maxHistorySize);
  this->tlmHistory_ChannelStructFreq = new History<TlmEntry_ChannelStructFreq>(maxHistorySize);
  this->tlmHistory_ChannelU32Limits = new History<TlmEntry_ChannelU32Limits>(maxHistorySize);
  this->tlmHistory_ChannelF32Limits = new History<TlmEntry_ChannelF32Limits>(maxHistorySize);
  this->tlmHistory_ChannelF64 = new History<TlmEntry_ChannelF64>(maxHistorySize);
  this->tlmHistory_ChannelU32OnChange = new History<TlmEntry_ChannelU32OnChange>(maxHistorySize);
  this->tlmHistory_ChannelEnumOnChange = new History<TlmEntry_ChannelEnumOnChange>(maxHistorySize);

  // Clear history
  this->clearHistory();
}

ActiveSerialTesterBase ::
  ~ActiveSerialTesterBase()
{
  // Destroy port histories
  delete this->fromPortHistory_typedOut;
  delete this->fromPortHistory_typedReturnOut;

  // Destroy command history
  delete this->cmdResponseHistory;

  // Destroy event histories
#if FW_ENABLE_TEXT_LOGGING
  delete this->textLogHistory;
#endif
  delete this->eventHistory_EventActivityLowThrottled;
  delete this->eventHistory_EventCommand;
  delete this->eventHistory_EventDiagnostic;
  delete this->eventHistory_EventFatalThrottled;
  delete this->eventHistory_EventWarningHigh;

  // Destroy telemetry histories
  delete this->tlmHistory_ChannelU32Format;
  delete this->tlmHistory_ChannelF32Format;
  delete this->tlmHistory_ChannelStringFormat;
  delete this->tlmHistory_ChannelEnum;
  delete this->tlmHistory_ChannelArrayFreq;
  delete this->tlmHistory_ChannelStructFreq;
  delete this->tlmHistory_ChannelU32Limits;
  delete this->tlmHistory_ChannelF32Limits;
  delete this->tlmHistory_ChannelF64;
  delete this->tlmHistory_ChannelU32OnChange;
  delete this->tlmHistory_ChannelEnumOnChange;
}

// ----------------------------------------------------------------------
// Handler base-class functions for from ports
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  from_typedOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_typedOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_typedOut_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 ActiveSerialTesterBase ::
  from_typedReturnOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_typedReturnOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->from_typedReturnOut_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  from_serialOut_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_from_serialOut(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->from_serialOut_handler(
    portNum,
    buffer
  );
}

// ----------------------------------------------------------------------
// Invocation functions for to ports
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  invoke_to_noArgsAsync(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsAsync[portNum].invoke();
}

void ActiveSerialTesterBase ::
  invoke_to_noArgsGuarded(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsGuarded[portNum].invoke();
}

U32 ActiveSerialTesterBase ::
  invoke_to_noArgsReturnGuarded(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnGuarded[portNum].invoke();
}

U32 ActiveSerialTesterBase ::
  invoke_to_noArgsReturnSync(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_noArgsReturnSync[portNum].invoke();
}

void ActiveSerialTesterBase ::
  invoke_to_noArgsSync(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_noArgsSync[portNum].invoke();
}

void ActiveSerialTesterBase ::
  invoke_to_typedAsync(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_typedAsyncAssert(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncAssert[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_typedAsyncBlockPriority(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncBlockPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_typedAsyncDropPriority(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedAsyncDropPriority[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_typedGuarded(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 ActiveSerialTesterBase ::
  invoke_to_typedReturnGuarded(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnGuarded[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 ActiveSerialTesterBase ::
  invoke_to_typedReturnSync(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_to_typedReturnSync[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_typedSync(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_typedSync[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialAsync(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialAsync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialAsync[portNum].invoke(
    buffer
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialAsyncAssert(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialAsyncAssert[portNum].invoke(
    buffer
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialAsyncBlockPriority(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialAsyncBlockPriority[portNum].invoke(
    buffer
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialAsyncDropPriority(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialAsyncDropPriority[portNum].invoke(
    buffer
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialGuarded(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialGuarded[portNum].invoke(
    buffer
  );
}

void ActiveSerialTesterBase ::
  invoke_to_serialSync(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_to_serialSync[portNum].invoke(
    buffer
  );
}

// ----------------------------------------------------------------------
// Getters for port counts
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_noArgsAsync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsAsync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_noArgsGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsGuarded));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_noArgsReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnGuarded));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_noArgsReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsReturnSync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_noArgsSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_noArgsSync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedAsync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedAsyncAssert() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncAssert));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedAsyncBlockPriority() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncBlockPriority));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedAsyncDropPriority() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedAsyncDropPriority));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedGuarded));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedReturnGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnGuarded));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedReturnSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedReturnSync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_typedSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_typedSync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialAsync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialAsync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialAsyncAssert() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialAsyncAssert));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialAsyncBlockPriority() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialAsyncBlockPriority));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialAsyncDropPriority() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialAsyncDropPriority));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialGuarded() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialGuarded));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_serialSync() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_serialSync));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_to_cmdIn() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_to_cmdIn));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_typedOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_typedReturnOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_typedReturnOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_serialOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_serialOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_cmdRegOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdRegOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_cmdResponseOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_cmdResponseOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_eventOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_eventOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_prmGetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmGetOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_prmSetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_prmSetOut));
}

#if FW_ENABLE_TEXT_LOGGING == 1

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_textEventOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_textEventOut));
}

#endif

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_timeGetOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_timeGetOut));
}

NATIVE_INT_TYPE ActiveSerialTesterBase ::
  getNum_from_tlmOut() const
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_from_tlmOut));
}

// ----------------------------------------------------------------------
// Connection status queries for to ports
// ----------------------------------------------------------------------

bool ActiveSerialTesterBase ::
  isConnected_to_noArgsAsync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsAsync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_noArgsGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsGuarded[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_noArgsReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnGuarded[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_noArgsReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsReturnSync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_noArgsSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_noArgsSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_noArgsSync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedAsync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedAsyncAssert(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncAssert[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedAsyncBlockPriority(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncBlockPriority[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedAsyncDropPriority(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedAsyncDropPriority[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedGuarded[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedReturnGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnGuarded[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedReturnSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedReturnSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedReturnSync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_typedSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_typedSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_typedSync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialAsync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialAsync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialAsyncAssert(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncAssert(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialAsyncAssert[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialAsyncBlockPriority(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncBlockPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialAsyncBlockPriority[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialAsyncDropPriority(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialAsyncDropPriority(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialAsyncDropPriority[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialGuarded(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialGuarded(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialGuarded[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_serialSync(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_serialSync(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_serialSync[portNum].isConnected();
}

bool ActiveSerialTesterBase ::
  isConnected_to_cmdIn(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_to_cmdIn(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_to_cmdIn[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Functions for testing commands
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  cmdResponseIn(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  CmdResponse e = { opCode, cmdSeq, response };
  this->cmdResponseHistory->push_back(e);
}

void ActiveSerialTesterBase ::
  sendRawCmd(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& buf
  )
{
  const U32 idBase = this->getIdBase();
  FwOpcodeType _opcode = opCode + idBase;
  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC_PRIMITIVE(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      U32 u32,
      F32 f32,
      bool b
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC_PRIMITIVE + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC_STRING(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      const Fw::CmdStringArg& str1,
      const Fw::CmdStringArg& str2
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(str2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC_STRING + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC_ENUM(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      E e
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC_ENUM + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC_ARRAY(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      A a
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC_ARRAY + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_SYNC_STRUCT(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      S s
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_SYNC_STRUCT + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED_PRIMITIVE(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      U32 u32,
      F32 f32,
      bool b
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED_PRIMITIVE + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED_STRING(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      const Fw::CmdStringArg& str1,
      const Fw::CmdStringArg& str2
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  _status = buf.serialize(str2);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED_STRING + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED_ENUM(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      E e
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED_ENUM + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED_ARRAY(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      A a
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED_ARRAY + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_GUARDED_STRUCT(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      S s
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_GUARDED_STRUCT + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_ASYNC(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_ASYNC + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_PRIORITY(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_PRIORITY + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_PARAMS_PRIORITY(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      U32 u32
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_PARAMS_PRIORITY + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_DROP(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer buf;

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_DROP + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

void ActiveSerialTesterBase ::
  sendCmd_CMD_PARAMS_PRIORITY_DROP(
      const NATIVE_INT_TYPE instance,
      U32 cmdSeq,
      U32 u32
  )
{
  // Serialize arguments
  Fw::CmdArgBuffer buf;
  Fw::SerializeStatus _status;

  _status = buf.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Call output command port
  FwOpcodeType _opcode;
  const U32 idBase = this->getIdBase();
  _opcode = ActiveSerialComponentBase::OPCODE_CMD_PARAMS_PRIORITY_DROP + idBase;

  if (this->m_to_cmdIn[0].isConnected()) {
    this->m_to_cmdIn[0].invoke(
      _opcode,
      cmdSeq,
      buf
    );
  }
  else {
    printf("Test Command Output port not connected!\n");
  }
}

// ----------------------------------------------------------------------
// Functions for testing events
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  dispatchEvents(
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      Fw::LogBuffer& args
  )
{

}

#if FW_ENABLE_TEXT_LOGGING

void ActiveSerialTesterBase ::
  textLogIn(
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity severity,
      const Fw::TextLogString& text
  )
{
  TextLogEntry e = { id, timeTag, severity, text };
  textLogHistory->push_back(e);
}

#endif

void ActiveSerialTesterBase ::
  logIn_ACTIVITY_HI_EventActivityHigh()
{
  this->eventsSize_EventActivityHigh++;
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_ACTIVITY_LO_EventActivityLowThrottled(
      U32 u32,
      F32 f32,
      bool b
  )
{
  EventEntry_EventActivityLowThrottled _e = {
    u32,
    f32,
    b
  };
  eventHistory_EventActivityLowThrottled->push_back(_e);
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_COMMAND_EventCommand(
      const Fw::LogStringArg& str1,
      const Fw::LogStringArg& str2
  )
{
  EventEntry_EventCommand _e = {
    str1,
    str2
  };
  eventHistory_EventCommand->push_back(_e);
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_DIAGNOSTIC_EventDiagnostic(E e)
{
  EventEntry_EventDiagnostic _e = {
    e
  };
  eventHistory_EventDiagnostic->push_back(_e);
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_FATAL_EventFatalThrottled(A a)
{
  EventEntry_EventFatalThrottled _e = {
    a
  };
  eventHistory_EventFatalThrottled->push_back(_e);
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_WARNING_HI_EventWarningHigh(S s)
{
  EventEntry_EventWarningHigh _e = {
    s
  };
  eventHistory_EventWarningHigh->push_back(_e);
  this->eventsSize++;
}

void ActiveSerialTesterBase ::
  logIn_WARNING_LO_EventWarningLowThrottled()
{
  this->eventsSize_EventWarningLowThrottled++;
  this->eventsSize++;
}

// ----------------------------------------------------------------------
// Functions for testing telemetry
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  dispatchTlm(
      FwChanIdType id,
      const Fw::Time& timeTag,
      Fw::TlmBuffer& val
  )
{
  val.resetDeser();

  const U32 idBase = this->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case ActiveSerialComponentBase::CHANNELID_CHANNELU32FORMAT: {
      U32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelU32Format: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelU32Format(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELF32FORMAT: {
      F32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelF32Format: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelF32Format(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELSTRINGFORMAT: {
      Fw::TlmString arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelStringFormat: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelStringFormat(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELENUM: {
      E arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelEnum: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelEnum(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELARRAYFREQ: {
      A arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelArrayFreq: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelArrayFreq(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELSTRUCTFREQ: {
      S arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelStructFreq: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelStructFreq(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELU32LIMITS: {
      U32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelU32Limits: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelU32Limits(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELF32LIMITS: {
      F32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelF32Limits: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelF32Limits(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELF64: {
      F64 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelF64: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelF64(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELU32ONCHANGE: {
      U32 arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelU32OnChange: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelU32OnChange(timeTag, arg);
      break;
    }

    case ActiveSerialComponentBase::CHANNELID_CHANNELENUMONCHANGE: {
      E arg;
      const Fw::SerializeStatus _status = val.deserialize(arg);

      if (_status != Fw::FW_SERIALIZE_OK) {
        printf("Error deserializing ChannelEnumOnChange: %d\n", _status);
        return;
      }

      this->tlmInput_ChannelEnumOnChange(timeTag, arg);
      break;
    }

    default: {
      FW_ASSERT(0, id);
      break;
    }
  }
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelU32Format(
      const Fw::Time& timeTag,
      const U32& val
  )
{
  TlmEntry_ChannelU32Format e = { timeTag, val };
  this->tlmHistory_ChannelU32Format->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelF32Format(
      const Fw::Time& timeTag,
      const F32& val
  )
{
  TlmEntry_ChannelF32Format e = { timeTag, val };
  this->tlmHistory_ChannelF32Format->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelStringFormat(
      const Fw::Time& timeTag,
      const Fw::TlmString& val
  )
{
  TlmEntry_ChannelStringFormat e = { timeTag, val };
  this->tlmHistory_ChannelStringFormat->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelEnum(
      const Fw::Time& timeTag,
      const E& val
  )
{
  TlmEntry_ChannelEnum e = { timeTag, val };
  this->tlmHistory_ChannelEnum->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelArrayFreq(
      const Fw::Time& timeTag,
      const A& val
  )
{
  TlmEntry_ChannelArrayFreq e = { timeTag, val };
  this->tlmHistory_ChannelArrayFreq->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelStructFreq(
      const Fw::Time& timeTag,
      const S& val
  )
{
  TlmEntry_ChannelStructFreq e = { timeTag, val };
  this->tlmHistory_ChannelStructFreq->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelU32Limits(
      const Fw::Time& timeTag,
      const U32& val
  )
{
  TlmEntry_ChannelU32Limits e = { timeTag, val };
  this->tlmHistory_ChannelU32Limits->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelF32Limits(
      const Fw::Time& timeTag,
      const F32& val
  )
{
  TlmEntry_ChannelF32Limits e = { timeTag, val };
  this->tlmHistory_ChannelF32Limits->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelF64(
      const Fw::Time& timeTag,
      const F64& val
  )
{
  TlmEntry_ChannelF64 e = { timeTag, val };
  this->tlmHistory_ChannelF64->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelU32OnChange(
      const Fw::Time& timeTag,
      const U32& val
  )
{
  TlmEntry_ChannelU32OnChange e = { timeTag, val };
  this->tlmHistory_ChannelU32OnChange->push_back(e);
  this->tlmSize++;
}

void ActiveSerialTesterBase ::
  tlmInput_ChannelEnumOnChange(
      const Fw::Time& timeTag,
      const E& val
  )
{
  TlmEntry_ChannelEnumOnChange e = { timeTag, val };
  this->tlmHistory_ChannelEnumOnChange->push_back(e);
  this->tlmSize++;
}

// ----------------------------------------------------------------------
// Functions to test parameters
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  paramSet_ParamU32(
      const U32& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamU32 = val;
  this->m_param_ParamU32_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamU32(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamU32) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMU32_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamU32(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMU32_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSet_ParamF64(
      const F64& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamF64 = val;
  this->m_param_ParamF64_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamF64(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamF64) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMF64_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamF64(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMF64_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSet_ParamString(
      const Fw::ParamString& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamString = val;
  this->m_param_ParamString_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamString(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamString) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMSTRING_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamString(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMSTRING_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSet_ParamEnum(
      const E& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamEnum = val;
  this->m_param_ParamEnum_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamEnum(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamEnum) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMENUM_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamEnum(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMENUM_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSet_ParamArray(
      const A& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamArray = val;
  this->m_param_ParamArray_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamArray(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamArray) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMARRAY_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamArray(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMARRAY_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSet_ParamStruct(
      const S& val,
      Fw::ParamValid valid
  )
{
  this->m_param_ParamStruct = val;
  this->m_param_ParamStruct_valid = valid;
}

void ActiveSerialTesterBase ::
  paramSend_ParamStruct(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  // Build command for parameter set
  Fw::CmdArgBuffer args;
  FW_ASSERT(
    args.serialize(this->m_param_ParamStruct) == Fw::FW_SERIALIZE_OK
  );

  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode =  ActiveSerialComponentBase::OPCODE_PARAMSTRUCT_SET + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

void ActiveSerialTesterBase ::
  paramSave_ParamStruct(
      NATIVE_INT_TYPE instance,
      U32 cmdSeq
  )
{
  Fw::CmdArgBuffer args;
  const U32 idBase = this->getIdBase();
  FwOpcodeType _prmOpcode = ActiveSerialComponentBase::OPCODE_PARAMSTRUCT_SAVE + idBase;

  if (not this->m_to_cmdIn[0].isConnected()) {
    printf("Test Command Output port not connected!\n");
  }
  else {
    this->m_to_cmdIn[0].invoke(
      _prmOpcode,
      cmdSeq,
      args
    );
  }
}

// ----------------------------------------------------------------------
// Functions to test time
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  setTestTime(const Fw::Time& timeTag)
{
  this->m_testTime = timeTag;
}

// ----------------------------------------------------------------------
// History functions
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  clearHistory()
{
  this->clearFromPortHistory();
  this->cmdResponseHistory->clear();
  this->textLogHistory->clear();
  this->clearEvents();
  this->clearTlm();
}

void ActiveSerialTesterBase ::
  clearFromPortHistory()
{
  this->fromPortHistorySize = 0;
  this->fromPortHistory_typedOut->clear();
  this->fromPortHistory_typedReturnOut->clear();
}

void ActiveSerialTesterBase ::
  pushFromPortEntry_typedOut(
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedOut _e = {
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  };
  this->fromPortHistory_typedOut->push_back(_e);
  this->fromPortHistorySize++;
}

void ActiveSerialTesterBase ::
  pushFromPortEntry_typedReturnOut(
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FromPortEntry_typedReturnOut _e = {
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  };
  this->fromPortHistory_typedReturnOut->push_back(_e);
  this->fromPortHistorySize++;
}

void ActiveSerialTesterBase ::
  clearEvents()
{
  this->eventsSize = 0;
  this->eventsSize_EventActivityHigh = 0;
  this->eventHistory_EventActivityLowThrottled->clear();
  this->eventHistory_EventCommand->clear();
  this->eventHistory_EventDiagnostic->clear();
  this->eventHistory_EventFatalThrottled->clear();
  this->eventHistory_EventWarningHigh->clear();
  this->eventsSize_EventWarningLowThrottled = 0;
}

#if FW_ENABLE_TEXT_LOGGING

void ActiveSerialTesterBase ::
  printTextLogHistoryEntry(
      const TextLogEntry& e,
      FILE* file
  )
{
  const char* severityString = "UNKNOWN";

  switch (e.severity.e) {
    case Fw::LogSeverity::FATAL:
      severityString = "FATAL";
      break;
    case Fw::LogSeverity::WARNING_HI:
      severityString = "WARNING_HI";
      break;
    case Fw::LogSeverity::WARNING_LO:
      severityString = "WARNING_LO";
      break;
    case Fw::LogSeverity::COMMAND:
      severityString = "COMMAND";
      break;
    case Fw::LogSeverity::ACTIVITY_HI:
      severityString = "ACTIVITY_HI";
      break;
    case Fw::LogSeverity::ACTIVITY_LO:
      severityString = "ACTIVITY_LO";
      break;
    case Fw::LogSeverity::DIAGNOSTIC:
     severityString = "DIAGNOSTIC";
      break;
    default:
      severityString = "SEVERITY ERROR";
      break;
  }

  fprintf(
    file,
    "EVENT: (%" PRI_FwEventIdType ") (%" PRI_FwTimeBaseStoreType ":%" PRIu32 ",%" PRIu32 ") %s: %s\n",
    e.id,
    static_cast<FwTimeBaseStoreType>(e.timeTag.getTimeBase()),
    e.timeTag.getSeconds(),
    e.timeTag.getUSeconds(),
    severityString,
    e.text.toChar()
  );
}

void ActiveSerialTesterBase ::
  printTextLogHistory(FILE* const file)
{
  for (U32 i = 0; i < this->textLogHistory->size(); i++) {
    this->printTextLogHistoryEntry(
      this->textLogHistory->at(i),
      file
    );
  }
}

#endif

void ActiveSerialTesterBase ::
  clearTlm()
{
  this->tlmSize = 0;
  this->tlmHistory_ChannelU32Format->clear();
  this->tlmHistory_ChannelF32Format->clear();
  this->tlmHistory_ChannelStringFormat->clear();
  this->tlmHistory_ChannelEnum->clear();
  this->tlmHistory_ChannelArrayFreq->clear();
  this->tlmHistory_ChannelStructFreq->clear();
  this->tlmHistory_ChannelU32Limits->clear();
  this->tlmHistory_ChannelF32Limits->clear();
  this->tlmHistory_ChannelF64->clear();
  this->tlmHistory_ChannelU32OnChange->clear();
  this->tlmHistory_ChannelEnumOnChange->clear();
}

// ----------------------------------------------------------------------
// Static functions for output ports
// ----------------------------------------------------------------------

void ActiveSerialTesterBase ::
  from_typedOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  _testerBase->from_typedOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 ActiveSerialTesterBase ::
  from_typedReturnOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  return _testerBase->from_typedReturnOut_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void ActiveSerialTesterBase ::
  from_serialOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  return _testerBase->from_serialOut_handlerBase(
    portNum,
    buffer
  );
}

void ActiveSerialTesterBase ::
  from_cmdRegOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode
  )
{

}

void ActiveSerialTesterBase ::
  from_cmdResponseOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      const Fw::CmdResponse& cmdResponse
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  _testerBase->cmdResponseIn(opCode, cmdSeq, cmdResponse);
}

void ActiveSerialTesterBase ::
  from_eventOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::LogBuffer& args
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  _testerBase->dispatchEvents(id, timeTag, severity, args);
}

Fw::ParamValid ActiveSerialTesterBase ::
  from_prmGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);

  Fw::SerializeStatus _status;
  Fw::ParamValid _ret = Fw::ParamValid::VALID;
  val.resetSer();

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);


  switch (id - idBase) {
    case ActiveSerialComponentBase::PARAMID_PARAMU32: {
      _status = val.serialize(_testerBase->m_param_ParamU32);
      _ret = _testerBase->m_param_ParamU32_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMF64: {
      _status = val.serialize(_testerBase->m_param_ParamF64);
      _ret = _testerBase->m_param_ParamF64_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMSTRING: {
      _status = val.serialize(_testerBase->m_param_ParamString);
      _ret = _testerBase->m_param_ParamString_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMENUM: {
      _status = val.serialize(_testerBase->m_param_ParamEnum);
      _ret = _testerBase->m_param_ParamEnum_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMARRAY: {
      _status = val.serialize(_testerBase->m_param_ParamArray);
      _ret = _testerBase->m_param_ParamArray_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMSTRUCT: {
      _status = val.serialize(_testerBase->m_param_ParamStruct);
      _ret = _testerBase->m_param_ParamStruct_valid;
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      break;
    };

    default:
      FW_ASSERT(id);
      break;
  }

  return _ret;
}

void ActiveSerialTesterBase ::
  from_prmSetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwPrmIdType id,
      Fw::ParamBuffer& val
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);

  Fw::SerializeStatus _status;
  val.resetSer();

  const U32 idBase = _testerBase->getIdBase();
  FW_ASSERT(id >= idBase, id, idBase);

  switch (id - idBase) {
    case ActiveSerialComponentBase::PARAMID_PARAMU32: {
      U32 ParamU32Val;
      _status = val.deserialize(ParamU32Val);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamU32Val ==
        _testerBase->m_param_ParamU32
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMF64: {
      F64 ParamF64Val;
      _status = val.deserialize(ParamF64Val);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamF64Val ==
        _testerBase->m_param_ParamF64
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMSTRING: {
      Fw::ParamString ParamStringVal;
      _status = val.deserialize(ParamStringVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStringVal ==
        _testerBase->m_param_ParamString
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMENUM: {
      E ParamEnumVal;
      _status = val.deserialize(ParamEnumVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamEnumVal ==
        _testerBase->m_param_ParamEnum
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMARRAY: {
      A ParamArrayVal;
      _status = val.deserialize(ParamArrayVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamArrayVal ==
        _testerBase->m_param_ParamArray
      );
      break;
    };

    case ActiveSerialComponentBase::PARAMID_PARAMSTRUCT: {
      S ParamStructVal;
      _status = val.deserialize(ParamStructVal);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
      FW_ASSERT(
        ParamStructVal ==
        _testerBase->m_param_ParamStruct
      );
      break;
    };

    default:
      FW_ASSERT(id);
      break;
  }
}

#if FW_ENABLE_TEXT_LOGGING == 1

void ActiveSerialTesterBase ::
  from_textEventOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwEventIdType id,
      Fw::Time& timeTag,
      const Fw::LogSeverity& severity,
      Fw::TextLogString& text
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  _testerBase->textLogIn(id, timeTag, severity, text);
}

#endif

void ActiveSerialTesterBase ::
  from_timeGetOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      Fw::Time& time
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  time = _testerBase->m_testTime;
}

void ActiveSerialTesterBase ::
  from_tlmOut_static(
      Fw::PassiveComponentBase* const callComp,
      NATIVE_INT_TYPE portNum,
      FwChanIdType id,
      Fw::Time& timeTag,
      Fw::TlmBuffer& val
  )
{
  ActiveSerialTesterBase* _testerBase = static_cast<ActiveSerialTesterBase*>(callComp);
  _testerBase->dispatchTlm(id, timeTag, val);
}
