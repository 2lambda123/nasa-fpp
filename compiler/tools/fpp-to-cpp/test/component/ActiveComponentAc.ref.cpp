// ======================================================================
// \title  ActiveComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Active component base class
// ======================================================================

#include <cstdio>

#include "ActiveComponentAc.hpp"
#include "Fw/Types/Assert.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif

namespace {
  enum MsgTypeEnum {
    ACTIVE_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
    TYPEDASYNC_TYPED,
    TYPEDASYNCASSERT_TYPED,
    TYPEDASYNCBLOCKPRIORITY_TYPED,
    TYPEDASYNCDROPPRIORITY_TYPED,
    SERIALASYNC_SERIAL,
    SERIALASYNCASSERT_SERIAL,
    SERIALASYNCBLOCKPRIORITY_SERIAL,
    SERIALASYNCDROPPRIORITY_SERIAL,
    CMD_CMD_ASYNC,
    CMD_CMD_PRIORITY,
    CMD_CMD_PARAMS_PRIORITY,
    CMD_CMD_DROP,
    CMD_CMD_PARAMS_PRIORITY_DROP,
    INT_IF_INTERNALARRAY,
    INT_IF_INTERNALENUM,
    INT_IF_INTERNALPRIMITIVE,
    INT_IF_INTERNALPRIORITYDROP,
    INT_IF_INTERNALSTRING,
    INT_IF_INTERNALSTRUCT,
  };
  // Define a message buffer class large enough to handle all the
  // asynchronous inputs to the component
  class ComponentIpcSerializableBuffer :
    public Fw::SerializeBufferBase
  {

    public:

      enum {
        // Max. message size = size of data + message id + port
        SERIALIZATION_SIZE =
          sizeof(BuffUnion) +
          sizeof(NATIVE_INT_TYPE) +
          sizeof(NATIVE_INT_TYPE)
      };

      NATIVE_UINT_TYPE getBuffCapacity() const {
        return sizeof(m_buff);
      }

      U8* getBuffAddr() {
        return m_buff;
      }

      const U8* getBuffAddr() const {
        return m_buff;
      }

    private:
      // Should be the max of all the input ports serialized sizes...
      U8 m_buff[SERIALIZATION_SIZE];

  };
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* ActiveComponentBase ::
  get_cmdIn_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdIn_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

InputTypedPort* ActiveComponentBase ::
  get_typedAsync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsync_InputPort[portNum];
}

InputTypedPort* ActiveComponentBase ::
  get_typedAsyncAssert_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncAssert_InputPort[portNum];
}

InputTypedPort* ActiveComponentBase ::
  get_typedAsyncBlockPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncBlockPriority_InputPort[portNum];
}

InputTypedPort* ActiveComponentBase ::
  get_typedAsyncDropPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncDropPriority_InputPort[portNum];
}

InputTypedPort* ActiveComponentBase ::
  get_typedGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedGuarded_InputPort[portNum];
}

InputTypedReturnPort* ActiveComponentBase ::
  get_typedReturnGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnGuarded_InputPort[portNum];
}

InputTypedReturnPort* ActiveComponentBase ::
  get_typedReturnSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnSync_InputPort[portNum];
}

InputTypedPort* ActiveComponentBase ::
  get_typedSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for serial input ports
// ----------------------------------------------------------------------

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialAsync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialAsync_InputPort[portNum];
}

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialAsyncAssert_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialAsyncAssert_InputPort[portNum];
}

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialAsyncBlockPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialAsyncBlockPriority_InputPort[portNum];
}

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialAsyncDropPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialAsyncDropPriority_InputPort[portNum];
}

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialGuarded_InputPort[portNum];
}

Fw::InputSerializePort* ActiveComponentBase ::
  get_serialSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_serialSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_serialSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect special input ports to special output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_prmGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void ActiveComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void ActiveComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_prmGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

#if FW_ENABLE_TEXT_LOGGING == 1

void ActiveComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

#endif

void ActiveComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

#endif

// ----------------------------------------------------------------------
// Connect typed input ports to typed output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].addCallPort(port);
}

void ActiveComponentBase ::
  set_typedReturnOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedReturnOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to typed output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_typedReturnOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

#endif

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to serial output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  set_serialOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{

}

void ActiveComponentBase ::
  set_serialOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPortBase* port
  )
{

}

#endif

// ----------------------------------------------------------------------
// Command registration
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  regCommands()
{

}

// ----------------------------------------------------------------------
// Parameter loading
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  loadParameters()
{

}

// ----------------------------------------------------------------------
// Component construction, initialization, and destruction
// ----------------------------------------------------------------------

ActiveComponentBase ::
  ActiveComponentBase(const char* compName) :
    Fw::ActiveComponentBase(compName)
{
  // Write telemetry channel ChannelU32OnChange
  this->m_first_update_ChannelU32OnChange = true;
  this->m_last_ChannelU32OnChange = 0;

  // Write telemetry channel ChannelEnumOnChange
  this->m_first_update_ChannelEnumOnChange = true;

  this->m_EventActivityLowThrottledThrottle = 0;
  this->m_EventFatalThrottledThrottle = 0;
  this->m_EventWarningLowThrottledThrottle = 0;

  this->m_param_ParamU32_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamF64_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamString_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamEnum_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamArray_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamStruct_valid = Fw::ParamValid::UNINIT;
}

void ActiveComponentBase ::
  init(
      NATIVE_INT_TYPE queueDepth,
      NATIVE_INT_TYPE msgSize,
      NATIVE_INT_TYPE instance
  )
{
  // Initialize base class
  Fw::ActiveComponentBase::init(instance);

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdIn_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsync_InputPorts());
    port++
  ) {
    this->m_typedAsync_InputPort[port].init();
    this->m_typedAsync_InputPort[port].addCallComp(
      this,
      m_p_typedAsync_in
    );
    this->m_typedAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncAssert_InputPorts());
    port++
  ) {
    this->m_typedAsyncAssert_InputPort[port].init();
    this->m_typedAsyncAssert_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncAssert_in
    );
    this->m_typedAsyncAssert_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncAssert_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncAssert_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncBlockPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncBlockPriority_InputPort[port].init();
    this->m_typedAsyncBlockPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncBlockPriority_in
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncBlockPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncDropPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncDropPriority_InputPort[port].init();
    this->m_typedAsyncDropPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncDropPriority_in
    );
    this->m_typedAsyncDropPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncDropPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncDropPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedGuarded_InputPorts());
    port++
  ) {
    this->m_typedGuarded_InputPort[port].init();
    this->m_typedGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedGuarded_in
    );
    this->m_typedGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnGuarded_InputPorts());
    port++
  ) {
    this->m_typedReturnGuarded_InputPort[port].init();
    this->m_typedReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedReturnGuarded_in
    );
    this->m_typedReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnSync_InputPorts());
    port++
  ) {
    this->m_typedReturnSync_InputPort[port].init();
    this->m_typedReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedReturnSync_in
    );
    this->m_typedReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedSync_InputPorts());
    port++
  ) {
    this->m_typedSync_InputPort[port].init();
    this->m_typedSync_InputPort[port].addCallComp(
      this,
      m_p_typedSync_in
    );
    this->m_typedSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialAsync_InputPorts());
    port++
  ) {
    this->m_serialAsync_InputPort[port].init();
    this->m_serialAsync_InputPort[port].addCallComp(
      this,
      m_p_serialAsync_in
    );
    this->m_serialAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialAsync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialAsync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialAsyncAssert_InputPorts());
    port++
  ) {
    this->m_serialAsyncAssert_InputPort[port].init();
    this->m_serialAsyncAssert_InputPort[port].addCallComp(
      this,
      m_p_serialAsyncAssert_in
    );
    this->m_serialAsyncAssert_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialAsyncAssert_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialAsyncAssert_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialAsyncBlockPriority_InputPorts());
    port++
  ) {
    this->m_serialAsyncBlockPriority_InputPort[port].init();
    this->m_serialAsyncBlockPriority_InputPort[port].addCallComp(
      this,
      m_p_serialAsyncBlockPriority_in
    );
    this->m_serialAsyncBlockPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialAsyncBlockPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialAsyncBlockPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialAsyncDropPriority_InputPorts());
    port++
  ) {
    this->m_serialAsyncDropPriority_InputPort[port].init();
    this->m_serialAsyncDropPriority_InputPort[port].addCallComp(
      this,
      m_p_serialAsyncDropPriority_in
    );
    this->m_serialAsyncDropPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialAsyncDropPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialAsyncDropPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialGuarded_InputPorts());
    port++
  ) {
    this->m_serialGuarded_InputPort[port].init();
    this->m_serialGuarded_InputPort[port].addCallComp(
      this,
      m_p_serialGuarded_in
    );
    this->m_serialGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialSync_InputPorts());
    port++
  ) {
    this->m_serialSync_InputPort[port].init();
    this->m_serialSync_InputPort[port].addCallComp(
      this,
      m_p_serialSync_in
    );
    this->m_serialSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdRegOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdResponseOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_eventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmSetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_textEventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_timeGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_tlmOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedOut_OutputPorts());
    port++
  ) {
    this->m_typedOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port Active
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_serialOut_OutputPorts());
    port++
  ) {
    this->m_serialOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_serialOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_serialOut_OutputPort[port].setObjName(portName);
#endif
  }
}

ActiveComponentBase ::
  ~ActiveComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_cmdIn_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedAsync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsync_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedAsyncAssert_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncAssert_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedAsyncBlockPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncBlockPriority_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedAsyncDropPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncDropPriority_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedGuarded_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedReturnGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnGuarded_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedReturnSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnSync_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of serial input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialAsync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialAsync_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialAsyncAssert_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialAsyncAssert_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialAsyncBlockPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialAsyncBlockPriority_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialAsyncDropPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialAsyncDropPriority_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialGuarded_InputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_cmdRegOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_cmdResponseOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_eventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_prmGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_prmSetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_textEventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_timeGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_tlmOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedOut_OutputPort));
}

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_typedReturnOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of serial output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE ActiveComponentBase ::
  getNum_serialOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_serialOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool ActiveComponentBase ::
  isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_eventOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_prmGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_prmSetOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

#if FW_ENABLE_TEXT_LOGGING == 1

bool ActiveComponentBase ::
  isConnected_textEventOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

#endif

bool ActiveComponentBase ::
  isConnected_timeGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_tlmOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

// ----------------------------------------------------------------------
// Connection status queries for typed output ports
// ----------------------------------------------------------------------

bool ActiveComponentBase ::
  isConnected_typedOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

bool ActiveComponentBase ::
  isConnected_typedReturnOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

// ----------------------------------------------------------------------
// Connection status queries for serial output ports
// ----------------------------------------------------------------------

bool ActiveComponentBase ::
  isConnected_serialOut_OutputPort(NATIVE_INT_TYPE portNum)
{

}

// ----------------------------------------------------------------------
// Handlers to implement for typed input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  typedAsync_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

void ActiveComponentBase ::
  typedAsyncAssert_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

void ActiveComponentBase ::
  typedAsyncBlockPriority_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

void ActiveComponentBase ::
  typedAsyncDropPriority_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

void ActiveComponentBase ::
  typedGuarded_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

F32 ActiveComponentBase ::
  typedReturnGuarded_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

F32 ActiveComponentBase ::
  typedReturnSync_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

void ActiveComponentBase ::
  typedSync_handler(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  typedAsync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str
  _status = msg.serialize(str);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  typedAsyncAssert_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncAssert_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCASSERT_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str
  _status = msg.serialize(str);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  typedAsyncBlockPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncBlockPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCBLOCKPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str
  _status = msg.serialize(str);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_BLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 10, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  typedAsyncDropPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncDropPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCDROPPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str
  _status = msg.serialize(str);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 5, _block);

  if (qStatus == Os::Queue::QUEUE_FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  typedGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  this->typedGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

F32 ActiveComponentBase ::
  typedReturnGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Lock guard mutex before calling
  this->lock();

  retVal = this->typedReturnGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

F32 ActiveComponentBase ::
  typedReturnSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  retVal = this->typedReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );

  return retVal;
}

void ActiveComponentBase ::
  typedSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->typedSync_handler(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Handlers to implement for serial input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  serialAsync_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

void ActiveComponentBase ::
  serialAsyncAssert_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

void ActiveComponentBase ::
  serialAsyncBlockPriority_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

void ActiveComponentBase ::
  serialAsyncDropPriority_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

void ActiveComponentBase ::
  serialGuarded_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

void ActiveComponentBase ::
  serialSync_handler(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

// ----------------------------------------------------------------------
// Port handler base-class functions for serial input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  serialAsync_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Declare buffer for serialAsync
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msgSerBuff(msgBuff, this->m_msgSize);
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msgSerBuff.serialize(
    static_cast<NATIVE_INT_TYPE>(SERIALASYNC_SERIAL)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msgSerBuff.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msgSerBuff.serialize(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msgSerBuff, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  serialAsyncAssert_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Declare buffer for serialAsyncAssert
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msgSerBuff(msgBuff, this->m_msgSize);
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msgSerBuff.serialize(
    static_cast<NATIVE_INT_TYPE>(SERIALASYNCASSERT_SERIAL)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msgSerBuff.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msgSerBuff.serialize(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msgSerBuff, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  serialAsyncBlockPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Declare buffer for serialAsyncBlockPriority
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msgSerBuff(msgBuff, this->m_msgSize);
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msgSerBuff.serialize(
    static_cast<NATIVE_INT_TYPE>(SERIALASYNCBLOCKPRIORITY_SERIAL)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msgSerBuff.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msgSerBuff.serialize(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_BLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msgSerBuff, 10, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  serialAsyncDropPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Declare buffer for serialAsyncDropPriority
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msgSerBuff(msgBuff, this->m_msgSize);
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msgSerBuff.serialize(
    static_cast<NATIVE_INT_TYPE>(SERIALASYNCDROPPRIORITY_SERIAL)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msgSerBuff.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument buffer
  _status = msgSerBuff.serialize(buffer);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msgSerBuff, 5, _block);

  if (qStatus == Os::Queue::QUEUE_FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void ActiveComponentBase ::
  serialGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  this->serialGuarded_handler(
    portNum,
    buffer
  );

  // Unlock guard mutex
  this->unLock();
}

void ActiveComponentBase ::
  serialSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_serialSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->serialSync_handler(
    portNum,
    buffer
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for typed async input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  typedAsync_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  typedAsyncAssert_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  typedAsyncBlockPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  typedAsyncDropPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Pre-message hooks for serial async input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  serialAsync_preMsgHook(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  serialAsyncAssert_preMsgHook(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  serialAsyncBlockPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Default: no-op
}

void ActiveComponentBase ::
  serialAsyncDropPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Invocation functions for typed output ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  typedOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

F32 ActiveComponentBase ::
  typedReturnOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{

}

// ----------------------------------------------------------------------
// Invocation functions for serial output ports
// ----------------------------------------------------------------------

Fw::SerializeStatus ActiveComponentBase ::
  serialOut_out(
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{

}

// ----------------------------------------------------------------------
// Internal interface handlers
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  internalArray_internalInterfaceHandler(const A& a)
{

}

void ActiveComponentBase ::
  internalEnum_internalInterfaceHandler(const E& e)
{

}

void ActiveComponentBase ::
  internalPrimitive_internalInterfaceHandler(
      U32 u32,
      F32 f32,
      bool b
  )
{

}

void ActiveComponentBase ::
  internalPriorityDrop_internalInterfaceHandler()
{

}

void ActiveComponentBase ::
  internalString_internalInterfaceHandler(
      const Fw::InternalInterfaceString& str1,
      const Fw::InternalInterfaceString& str2
  )
{

}

void ActiveComponentBase ::
  internalStruct_internalInterfaceHandler(const S& s)
{

}

// ----------------------------------------------------------------------
// Internal interface base-class functions
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  internalArray_internalInterfaceInvoke(const A& a)
{

}

void ActiveComponentBase ::
  internalEnum_internalInterfaceInvoke(const E& e)
{

}

void ActiveComponentBase ::
  internalPrimitive_internalInterfaceInvoke(
      U32 u32,
      F32 f32,
      bool b
  )
{

}

void ActiveComponentBase ::
  internalPriorityDrop_internalInterfaceInvoke()
{

}

void ActiveComponentBase ::
  internalString_internalInterfaceInvoke(
      const Fw::InternalInterfaceString& str1,
      const Fw::InternalInterfaceString& str2
  )
{

}

void ActiveComponentBase ::
  internalStruct_internalInterfaceInvoke(const S& s)
{

}

// ----------------------------------------------------------------------
// Command response
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  cmdResponse_out(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{

}

// ----------------------------------------------------------------------
// Command handlers to implement
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  CMD_SYNC_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_PRIMITIVE_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      U32 u32,
      F32 f32,
      bool b
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_STRING_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      const Fw::CmdStringArg& str1,
      const Fw::CmdStringArg& str2
  )
{

}

void ActiveComponentBase ::
  CMD_ASYNC_ENUM_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      E e
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_ARRAY_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      A a
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_STRUCT_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      S s
  )
{

}

void ActiveComponentBase ::
  CMD_ASYNC_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PRIORITY_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      U32 u32
  )
{

}

void ActiveComponentBase ::
  CMD_DROP_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_DROP_cmdHandler(
      FwOpcodeType opCode,
      U32 cmdSeq,
      U32 u32
  )
{

}

// ----------------------------------------------------------------------
// Command handler base-class functions
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  CMD_SYNC_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_PRIMITIVE_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_STRING_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_ASYNC_ENUM_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_ARRAY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_SYNC_STRUCT_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_ASYNC_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_PRIORITY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_DROP_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_DROP_cmdHandlerBase(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{

}

// ----------------------------------------------------------------------
// Pre-message hooks for async commands
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  CMD_ASYNC_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PRIORITY_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_DROP_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

void ActiveComponentBase ::
  CMD_PARAMS_PRIORITY_DROP_preMsgHook(
      FwOpcodeType opCode,
      U32 cmdSeq
  )
{

}

// ----------------------------------------------------------------------
// Event logging functions
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  log_ACTIVITY_HI_EventActivityHigh()
{

}

void ActiveComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled(
      U32 u32,
      F32 f32,
      bool b
  )
{

}

void ActiveComponentBase ::
  log_COMMAND_EventCommand(
      const Fw::LogStringArg& str1,
      const Fw::LogStringArg& str2
  )
{

}

void ActiveComponentBase ::
  log_DIAGNOSTIC_EventDiagnostic(E e)
{

}

void ActiveComponentBase ::
  log_FATAL_EventFatalThrottled(A a)
{

}

void ActiveComponentBase ::
  log_WARNING_HI_EventWarningHigh(S s)
{

}

void ActiveComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled()
{

}

// ----------------------------------------------------------------------
// Event throttle reset functions
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled_ThrottleClear()
{

}

void ActiveComponentBase ::
  log_FATAL_EventFatalThrottled_ThrottleClear()
{

}

void ActiveComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled_ThrottleClear()
{

}

// ----------------------------------------------------------------------
// Telemetry write functions
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  tlmWrite_ChannelU32Format(
      U32 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelF32Format(
      F32 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelStringFormat(
      const Fw::TlmString& arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelEnum(
      const E& arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelArrayFreq(
      const A& arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelStructFreq(
      const S& arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelU32Limits(
      U32 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelF32Limits(
      F32 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelF64(
      F64 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelU32OnChange(
      U32 arg,
      Fw::Time _tlmTime
  )
{

}

void ActiveComponentBase ::
  tlmWrite_ChannelEnumOnChange(
      const E& arg,
      Fw::Time _tlmTime
  )
{

}

// ----------------------------------------------------------------------
// Parameter update hook
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  parameterUpdated(FwPrmIdType id)
{

}

void ActiveComponentBase ::
  parametersLoaded()
{

}

// ----------------------------------------------------------------------
// Parameter get functions
// ----------------------------------------------------------------------

U32 ActiveComponentBase ::
  paramGet_ParamU32(Fw::ParamValid& isValid)
{

}

F64 ActiveComponentBase ::
  paramGet_ParamF64(Fw::ParamValid& isValid)
{

}

Fw::ParamString ActiveComponentBase ::
  paramGet_ParamString(Fw::ParamValid& isValid)
{

}

E ActiveComponentBase ::
  paramGet_ParamEnum(Fw::ParamValid& isValid)
{

}

A ActiveComponentBase ::
  paramGet_ParamArray(Fw::ParamValid& isValid)
{

}

S ActiveComponentBase ::
  paramGet_ParamStruct(Fw::ParamValid& isValid)
{

}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time ActiveComponentBase ::
  getTime()
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Mutex operations for guarded ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  lock()
{
  this->m_guardedPortMutex.lock();
}

void ActiveComponentBase ::
  unLock()
{
  this->m_guardedPortMutex.unLock();
}

// ----------------------------------------------------------------------
// Message dispatch functions
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus ActiveComponentBase ::
  doDispatch()
{
  U8 msgBuff[this->m_msgSize];
  Fw::ExternalSerializeBuffer msg(msgBuff,this->m_msgSize);
  NATIVE_INT_TYPE priority = 0;

  Os::Queue::QueueStatus msgStatus = this->m_queue.receive(
    msg,
    priority,
    Os::Queue::QUEUE_BLOCKING
  );
  FW_ASSERT(
    msgStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(msgStatus)
  );

  // Reset to beginning of buffer
  msg.resetDeser();

  NATIVE_INT_TYPE desMsg = 0;
  Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
  FW_ASSERT(
    deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(deserStatus)
  );

  MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);

  if (msgType == ACTIVE_COMPONENT_EXIT) {
    return MSG_DISPATCH_EXIT;
  }

  NATIVE_INT_TYPE portNum = 0;
  deserStatus = msg.deserialize(portNum);
  FW_ASSERT(
    deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(deserStatus)
  );

  switch (msgType) {
    // Handle async input port typedAsync
    case TYPEDASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str
      TypedPortStrings::StringSize80 str;
      deserStatus = msg.deserialize(str);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->typedAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncAssert
    case TYPEDASYNCASSERT_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str
      TypedPortStrings::StringSize80 str;
      deserStatus = msg.deserialize(str);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->typedAsyncAssert_handler(
        portNum,
        u32,
        f32,
        b,
        str,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncBlockPriority
    case TYPEDASYNCBLOCKPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str
      TypedPortStrings::StringSize80 str;
      deserStatus = msg.deserialize(str);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->typedAsyncBlockPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncDropPriority
    case TYPEDASYNCDROPPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str
      TypedPortStrings::StringSize80 str;
      deserStatus = msg.deserialize(str);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->typedAsyncDropPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port serialAsync
    case SERIALASYNC_SERIAL: {
      // Deserialize serialized buffer into new buffer
      U8 handBuff[this->m_msgSize];
      Fw::ExternalSerializeBuffer serHandBuff(handBuff,this->m_msgSize);
      deserStatus = msg.deserialize(serHandBuff);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      this->serialAsync_handler(portNum, serHandBuff);

      break;
    }

    // Handle async input port serialAsyncAssert
    case SERIALASYNCASSERT_SERIAL: {
      // Deserialize serialized buffer into new buffer
      U8 handBuff[this->m_msgSize];
      Fw::ExternalSerializeBuffer serHandBuff(handBuff,this->m_msgSize);
      deserStatus = msg.deserialize(serHandBuff);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      this->serialAsyncAssert_handler(portNum, serHandBuff);

      break;
    }

    // Handle async input port serialAsyncBlockPriority
    case SERIALASYNCBLOCKPRIORITY_SERIAL: {
      // Deserialize serialized buffer into new buffer
      U8 handBuff[this->m_msgSize];
      Fw::ExternalSerializeBuffer serHandBuff(handBuff,this->m_msgSize);
      deserStatus = msg.deserialize(serHandBuff);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      this->serialAsyncBlockPriority_handler(portNum, serHandBuff);

      break;
    }

    // Handle async input port serialAsyncDropPriority
    case SERIALASYNCDROPPRIORITY_SERIAL: {
      // Deserialize serialized buffer into new buffer
      U8 handBuff[this->m_msgSize];
      Fw::ExternalSerializeBuffer serHandBuff(handBuff,this->m_msgSize);
      deserStatus = msg.deserialize(serHandBuff);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      this->serialAsyncDropPriority_handler(portNum, serHandBuff);

      break;
    }

    // Handle command CMD_ASYNC
    case CMD_CMD_ASYNC: {
      // Deserialize opcode
      FwOpcodeType opCode = 0;
      deserStatus = msg.deserialize(opCode);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command sequence
      U32 cmdSeq = 0;
      deserStatus = msg.deserialize(cmdSeq);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      deserStatus = msg.deserialize(args);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_ASYNC_cmdHandler(opCode, cmdSeq);

      break;
    }

    // Handle command CMD_PRIORITY
    case CMD_CMD_PRIORITY: {
      // Deserialize opcode
      FwOpcodeType opCode = 0;
      deserStatus = msg.deserialize(opCode);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command sequence
      U32 cmdSeq = 0;
      deserStatus = msg.deserialize(cmdSeq);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      deserStatus = msg.deserialize(args);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PRIORITY_cmdHandler(opCode, cmdSeq);

      break;
    }

    // Handle command CMD_PARAMS_PRIORITY
    case CMD_CMD_PARAMS_PRIORITY: {
      // Deserialize opcode
      FwOpcodeType opCode = 0;
      deserStatus = msg.deserialize(opCode);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command sequence
      U32 cmdSeq = 0;
      deserStatus = msg.deserialize(cmdSeq);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      deserStatus = msg.deserialize(args);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Deserialize argument u32
      U32 u32;
      deserStatus = args.deserialize(u32);
      if (deserStatus != Fw::FW_SERIALIZE_OK) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(
              opCode,
              cmdSeq,
              Fw::CmdResponse::FORMAT_ERROR
          );
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PARAMS_PRIORITY_cmdHandler(
        opCode,
        cmdSeq,
        u32
      );

      break;
    }

    // Handle command CMD_DROP
    case CMD_CMD_DROP: {
      // Deserialize opcode
      FwOpcodeType opCode = 0;
      deserStatus = msg.deserialize(opCode);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command sequence
      U32 cmdSeq = 0;
      deserStatus = msg.deserialize(cmdSeq);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      deserStatus = msg.deserialize(args);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_DROP_cmdHandler(opCode, cmdSeq);

      break;
    }

    // Handle command CMD_PARAMS_PRIORITY_DROP
    case CMD_CMD_PARAMS_PRIORITY_DROP: {
      // Deserialize opcode
      FwOpcodeType opCode = 0;
      deserStatus = msg.deserialize(opCode);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command sequence
      U32 cmdSeq = 0;
      deserStatus = msg.deserialize(cmdSeq);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize command argument buffer
      Fw::CmdArgBuffer args;
      deserStatus = msg.deserialize(args);
      FW_ASSERT (
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Reset buffer
      args.resetDeser();

      // Deserialize argument u32
      U32 u32;
      deserStatus = args.deserialize(u32);
      if (deserStatus != Fw::FW_SERIALIZE_OK) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(
              opCode,
              cmdSeq,
              Fw::CmdResponse::FORMAT_ERROR
          );
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }

      // Make sure there was no data left over.
      // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
      if (args.getBuffLeft() != 0) {
        if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
          this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
        }
        // Don't crash the task if bad arguments were passed from the ground
        break;
      }
#endif

      // Call handler function
      this->CMD_PARAMS_PRIORITY_DROP_cmdHandler(
        opCode,
        cmdSeq,
        u32
      );

      break;
    }

    // Handle internal interface internalArray
    case INT_IF_INTERNALARRAY: {
      A a;
      deserStatus = msg.deserialize(a);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->internalArray_internalInterfaceHandler(
        a
      );

      break;
    }

    // Handle internal interface internalEnum
    case INT_IF_INTERNALENUM: {
      E e;
      deserStatus = msg.deserialize(e);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->internalEnum_internalInterfaceHandler(
        e
      );

      break;
    }

    // Handle internal interface internalPrimitive
    case INT_IF_INTERNALPRIMITIVE: {
      U32 u32;
      deserStatus = msg.deserialize(u32);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      F32 f32;
      deserStatus = msg.deserialize(f32);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      bool b;
      deserStatus = msg.deserialize(b);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->internalPrimitive_internalInterfaceHandler(
        u32,
        f32,
        b
      );

      break;
    }

    // Handle internal interface internalPriorityDrop
    case INT_IF_INTERNALPRIORITYDROP: {

      // Call handler function
      this->internalPriorityDrop_internalInterfaceHandler(

      );

      break;
    }

    // Handle internal interface internalString
    case INT_IF_INTERNALSTRING: {
      Fw::InternalInterfaceString str1;
      deserStatus = msg.deserialize(str1);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      Fw::InternalInterfaceString str2;
      deserStatus = msg.deserialize(str2);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->internalString_internalInterfaceHandler(
        str1,
        str2
      );

      break;
    }

    // Handle internal interface internalStruct
    case INT_IF_INTERNALSTRUCT: {
      S s;
      deserStatus = msg.deserialize(s);

      // Internal interface should always deserialize
      FW_ASSERT(
        Fw::FW_SERIALIZE_OK == deserStatus,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Call handler function
      this->internalStruct_internalInterfaceHandler(
        s
      );

      break;
    }

    default:
      return MSG_DISPATCH_ERROR;
  }

  return MSG_DISPATCH_OK;
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, opCode, idBase);

  // Select base class function based on opcode
  switch (opCode - idBase) {
    case OPCODE_CMD_SYNC: {
      compPtr->CMD_SYNC_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_PRIMITIVE: {
      compPtr->CMD_SYNC_PRIMITIVE_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_STRING: {
      compPtr->CMD_SYNC_STRING_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_ASYNC_ENUM: {
      compPtr->CMD_ASYNC_ENUM_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_ARRAY: {
      compPtr->CMD_SYNC_ARRAY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_SYNC_STRUCT: {
      compPtr->CMD_SYNC_STRUCT_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_ASYNC: {
      compPtr->CMD_ASYNC_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PRIORITY: {
      compPtr->CMD_PRIORITY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PARAMS_PRIORITY: {
      compPtr->CMD_PARAMS_PRIORITY_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_DROP: {
      compPtr->CMD_DROP_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_CMD_PARAMS_PRIORITY_DROP: {
      compPtr->CMD_PARAMS_PRIORITY_DROP_cmdHandlerBase(
        opCode,
        cmdSeq,
        args
      );
      break;
    }

    case OPCODE_PARAMU32_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamU32(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMU32_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamU32();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamF64(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamF64();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamString(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamString();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamEnum(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamEnum();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamArray(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamArray();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamStruct(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamStruct();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }
  }
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void ActiveComponentBase ::
  m_p_typedAsync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

void ActiveComponentBase ::
  m_p_typedAsyncAssert_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedAsyncAssert_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

void ActiveComponentBase ::
  m_p_typedAsyncBlockPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedAsyncBlockPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

void ActiveComponentBase ::
  m_p_typedAsyncDropPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedAsyncDropPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

void ActiveComponentBase ::
  m_p_typedGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

F32 ActiveComponentBase ::
  m_p_typedReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  return compPtr->typedReturnGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

F32 ActiveComponentBase ::
  m_p_typedReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  return compPtr->typedReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

void ActiveComponentBase ::
  m_p_typedSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->typedSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Calls for messages received on serial input ports
// ----------------------------------------------------------------------

#if FW_PORT_SERIALIZATION

void ActiveComponentBase ::
  m_p_serialAsync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialAsync_handlerBase(
    portNum,
    buffer
  );
}

void ActiveComponentBase ::
  m_p_serialAsyncAssert_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialAsyncAssert_handlerBase(
    portNum,
    buffer
  );
}

void ActiveComponentBase ::
  m_p_serialAsyncBlockPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialAsyncBlockPriority_handlerBase(
    portNum,
    buffer
  );
}

void ActiveComponentBase ::
  m_p_serialAsyncDropPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialAsyncDropPriority_handlerBase(
    portNum,
    buffer
  );
}

void ActiveComponentBase ::
  m_p_serialGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialGuarded_handlerBase(
    portNum,
    buffer
  );
}

void ActiveComponentBase ::
  m_p_serialSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      Fw::SerializeBufferBase& buffer
  )
{
  FW_ASSERT(callComp);
  ActiveComponentBase* compPtr = static_cast<ActiveComponentBase*>(callComp);
  compPtr->serialSync_handlerBase(
    portNum,
    buffer
  );
}

#endif

// ----------------------------------------------------------------------
// Private parameter get function
// ----------------------------------------------------------------------

Fw::ParamValid ActiveComponentBase ::
  getParam(
      FwPrmIdType id,
      Fw::ParamBuffer& buff
  )
{

}

// ----------------------------------------------------------------------
// Parameter set functions
// ----------------------------------------------------------------------

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamU32(Fw::SerializeBufferBase& val)
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamF64(Fw::SerializeBufferBase& val)
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamString(Fw::SerializeBufferBase& val)
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamEnum(Fw::SerializeBufferBase& val)
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamArray(Fw::SerializeBufferBase& val)
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSet_ParamStruct(Fw::SerializeBufferBase& val)
{

}

// ----------------------------------------------------------------------
// Parameter save functions
// ----------------------------------------------------------------------

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamU32()
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamF64()
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamString()
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamEnum()
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamArray()
{

}

Fw::CmdResponse ActiveComponentBase ::
  paramSave_ParamStruct()
{

}

#if FW_ENABLE_TEXT_LOGGING == 1

#endif
